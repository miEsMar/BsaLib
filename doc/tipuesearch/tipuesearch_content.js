var tipuesearch = {"pages":[{"title":" BsaLib ","text":"BsaLib Brief Description Build system Documentation License Code structure BsaLib: core library BSA: executable program Cross-platform support What's missing? Further developments Known Issues Related Scientific Publications Brief Description BsaLib , a Modern Fortran Library for the Bispectral Stochastic Analysis \nof structures under non-Gaussian stationary random actions. NOTE: currently, only wind action is included in the library, but other phenomena (waves for instance) can be easily integrated. \nSee further developments . Build system BsaLib uses CMake as a build system generator. Documentation BsaLib documentation is generated using FORD . License BsaLib is release under the GNU Lesser General Public License v3.0 .\nVisit the GPL official website for more information. Code structure There are two parts in this repository: BsaLib , the core library; BSA , the built-in executable program. BsaLib : core library BsaLib is the main core of this repository. \nIt consists of the main library and its API to which anyone could link to and interact with.\nTo use BsaLib , simply import the main BsaLib API module: program test use , non_intrinsic :: BsaLib implicit none ( type , external ) ! your declarations here ! your logic here ! initialise BsaLib call bsa_Init () ! set BsaLib internal state through its API procedures ! once done, run BsaLib call bsa_Run ( ... args ... ) ! finally, release BsaLib memory call bsa_Finalise () end program Being designed as a plug-in library, it needs the hosting program/library \nto provide some data needed by BsaLib in order to function properly.\nFor more details on the public API, visit the main documentation page . BSA : executable program As a side project package, a single-source executable file is provided under ./app/ . \nIt emulates what one would normally do when using BsaLib as a plug-in for its own \nlibrary/program. \nOn the other hand, this program is thought and provided for all those interested in using BsaLib but not having any hosting library/program. \nNonetheless, even if this program is provided, the user would yet need to provide the data \nfor BsaLib to function properly. If any of this data is not provided, the BsaLib runtime check \nwould detect it and abort correct logic flow. For that, the provided executable program relies on reading two input files: BsaLib related settings (formatted file, named bsa.bsadata ). \nFor details, read the dedicated section . External data file (named bsa.extdata ), in binary format, containing 8-byte floating point records \n( real64 of the iso_fortran_env compiler intrinsic module). \nFor full details, \nread the external data section . Cross-platform support BsaLib strives to be as cross-platform as possible, so that any user can use it regardless of \nthe tooling availability.\nCurrently, the code has been compiled and tested under three different OS-compiler configurations: Windows OS Build 10.0.19045 - Intel Fortran Compilers ( ifort 2021.7.1-20221019_000000 , ifx 2022.2.1-20221101 ) MacOS - GFortran 13.2 Linux Centos Fedora 8.7 - Intel Fortran Compilers ( ifort 2021.10.0-20230609 , ifx 2023.2.0-20230721 ) For the Proper Orthogonal Decomposition (POD) problem, two approaches have been tested, for configurations\n1 and 3: Linkage to proprietary Intel MKL (Math Kernel Libraries) Linkage to LAPACK native implementation \n( NOTE : from direct source build in configuration 1) What's missing? Further developments Mathematical: [ ] Integrate models for other non-Gaussian actions (waves, for instance) [ ] Extend to non-diagonal modal Frequency Response Function (FRF) models [ ] Extend to frequency-dependent modal matrices (e.g. aeroelastic phenomena in Wind Engineering) [ ] Add library core to generate spectra (PSDs and Bispectra) from time series Numerical: [ ] Adapt Classic approach to dump BFM info as in Mesher (easy) [ ] Improve internal policy mechanism and integration (WIP) [ ] Provide a general API for user defined models integration [ ] Complete full support for spatial (in-plane) symmetries of a real-valued bispectrum [ ] Compute nodal correlation internally (don't require it as user data) [ ] Add support for Mesher zones' interest modes [ ] Add a local caching system [ ] Add MPI support (for running BsaLib on multi-node clusters) [ ] Improve and extend GPU offloading capabilities [ ] Provide automation service to convert user-level model function into GPU-kernel code [ ] Enhance the mechanism that lets the user provide its own desired exporting function, \nso that BsaLib is not tight to any specific exporting format. [ ] Integrate a built-in bispectrum post-processing Visualiser (using Vulkan , for optimal performances) Known Issues There is one main known issue in the current version. Using OpenMP parallelisation in the second Post-meshing phase, \nexecution time is higher compared to serialised version. \nThis is due to the necessary synchronisation between threads when accessing \nshared file I/O when reading each zone's dumped data, causing the critical section to be the main bottleneck in this part.\nFor a proper use of OpenMP parallelisation in Post-meshing phase, a fundamental\nrethinking of the algorithmic structure needs to be done.\nA first, temporary, possible solution, could be the usage of thread-level private\nI/O with dedicated units, avoiding the need to synchronise when reading back \ninformation in post-meshing phase. However, this might soon become inelegant solution \nwhen the number of threads would start increasing considerably.\nFor this, as a temporary solution, a conditional compilation flag \n( BSA_USE_POST_MESH_OMP ) can be used to control effective use of OpenMP parallelisation in Post-meshing phase, disabled by default . Related Scientific Publications Non-Gaussian buffeting analysis of large structures by means of a Proper Orthogonal Decomposition A multiple timescale approach of bispectral correlation On the background and biresonant components of the random response of single degree-of-freedom systems under non-Gaussian random loading Developer Info Michele Esposito Marzino","tags":"home","loc":"index.html"},{"title":"exportInterf_vect_ – BsaLib","text":"interface public  subroutine exportInterf_vect_(f1, f2, brm, pdata) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: f1 (:) Array of frequencies along the X-axis real(kind=bsa_real_t), intent(in) :: f2 (:) Array of frequencies along the Y-axis real(kind=bsa_real_t), intent(in) :: brm (:,:) Data of bispectra class(*), intent(in), pointer :: pdata Unlimited polymorphic object allowinf the user to pass any kind of\nobject, holding the necessary data to be used when backfiring the\nprovided callback function when exporting bispectra information.","tags":"","loc":"interface\\exportinterf_vect_.html"},{"title":"bsa_Finalise – BsaLib","text":"interface public module subroutine bsa_Finalise() Arguments None Description Once BsaLib has finished, call this API procedure to ensure the cleanup of internal memory.","tags":"","loc":"interface\\bsa_finalise.html"},{"title":"bsa_Init – BsaLib","text":"interface public module subroutine bsa_Init() Arguments None Description Initialises BsaLib runtime internals","tags":"","loc":"interface\\bsa_init.html"},{"title":"bsa_Run – BsaLib","text":"interface public module subroutine bsa_Run(m2mf_cls, m2mr_cls, m2o2mr_cls, m3mf_msh, m3mr_msh, m3mf_cls, m3mr_cls) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), target, allocatable, dimension(:) :: m2mf_cls order moments, modal forces, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m2mr_cls order moments, modal responses, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m2o2mr_cls order spectral moments, modal responses, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mf_msh order moments, modal forces, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mr_msh order moments, modal responses, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mf_cls order moments, modal forces, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mr_cls order moments, modal responses, approach Description Main BsaLib procedure.\nThis should be the last API call to make, after all settings has been done.\nAt return, post-processing API calls can be done to export/elaborate results. Note For any argument that is not desired (provided that internal settings are compatible),\na null() argument can be passed.","tags":"","loc":"interface\\bsa_run.html"},{"title":"bsa_closeUnitsAtEnd – BsaLib","text":"interface public module subroutine bsa_closeUnitsAtEnd() Arguments None Description If called, tells BsaLib to close internal unit handles at exit.\nThis is not a wanted behaviour if, for example, output unit is taken from\nhosting program unit (see bsa_setOutUnit ),\nand might be used even after BsaLib returns from main ( bsa_Run ).","tags":"","loc":"interface\\bsa_closeunitsatend.html"},{"title":"bsa_computeBRdecomp – BsaLib","text":"interface public module subroutine bsa_computeBRdecomp(m2mf, bkg, res) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: m2mf (:) real(kind=bsa_real_t), intent(out), allocatable :: bkg (:) real(kind=bsa_real_t), intent(out), allocatable :: res (:) Description Returns the Background-Resonant decomposition, given the second order statistical moments of the modal loads. Note This is an API call to be used in a post-processing phase.","tags":"","loc":"interface\\bsa_computebrdecomp.html"},{"title":"bsa_computePeakFactors – BsaLib","text":"interface public module subroutine bsa_computePeakFactors(m2, m2o2, obs_time, peak_g, sk, peak_ng_pos, peak_ng_neg) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: m2 (:) real(kind=bsa_real_t), intent(in) :: m2o2 (:) real(kind=bsa_real_t), intent(in) :: obs_time real(kind=bsa_real_t), intent(inout), allocatable :: peak_g (:) real(kind=bsa_real_t), intent(in), allocatable :: sk (:) real(kind=bsa_real_t), intent(inout), allocatable :: peak_ng_pos (:) real(kind=bsa_real_t), intent(inout), optional, allocatable :: peak_ng_neg (:) Description Computes Gaussian and Non-Gaussian Peak factors.\nFormulations are taken from CITE!. Note This is an API call to be used in a post-processing phase.","tags":"","loc":"interface\\bsa_computepeakfactors.html"},{"title":"bsa_doValidateModalData – BsaLib","text":"interface public module subroutine bsa_doValidateModalData(bool) Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool If .false. (DEFAULT), do not perform any modal data validation.\n If .true. , checks if some modes in the structural modal matrix are not 1-normalised, and removes them from the effectively kept modes.\n This is to avoid having statistical moments of modal responses that are not computed\n with the same normalisation across all vibration modes (e.g. vertical and torsional modes). Bug As per the current implementation, all non 1-normalised modes are discarded.\nHowever, this might not be the desired behaviour, if for example, modes are\nnormalised with a criteria different than the 1-normalisation approach,\nor if only torsional modes (which are usually normalised to rotations and not displacements)\nare to be considered.\nA fix is certainly needed to remove this limitation. Description Enables (or disables, default option) validation of modal (structural) data.","tags":"","loc":"interface\\bsa_dovalidatemodaldata.html"},{"title":"bsa_doValidateZoneDeltas – BsaLib","text":"interface public module subroutine bsa_doValidateZoneDeltas(bool) Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool Description If .true. is given, enables zone's deltas validation.","tags":"","loc":"interface\\bsa_dovalidatezonedeltas.html"},{"title":"bsa_enableGPU – BsaLib","text":"interface public module subroutine bsa_enableGPU() Arguments None Description Enables GPU code.","tags":"","loc":"interface\\bsa_enablegpu.html"},{"title":"bsa_enableOnlyPremesh – BsaLib","text":"interface public module subroutine bsa_enableOnlyPremesh() Arguments None Description If called, exits after Pre-mesh phase. Skips Post-mesh.","tags":"","loc":"interface\\bsa_enableonlypremesh.html"},{"title":"bsa_enableVisualMode – BsaLib","text":"interface public module subroutine bsa_enableVisualMode() Arguments None Description Enables visual mode.\n Visual mode allows the user to write bispectra of modal/nodal responses.\n When in visual mode, Pre-mesh phase is skipped, and data read from file ( dumpfile ).\n Only the Post-mesh phase is done (mostly interpolation ), and data written to files.","tags":"","loc":"interface\\bsa_enablevisualmode.html"},{"title":"bsa_exportBRdecomp – BsaLib","text":"public interface bsa_exportBRdecomp Module Procedures private  interface bsa_exportBR_nocompute_() Arguments None","tags":"","loc":"interface\\bsa_exportbrdecomp.html"},{"title":"bsa_exportBispToFile – BsaLib","text":"interface public module subroutine bsa_exportBispToFile(fname, bisp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: bisp (:,:,:) Description Exports series of Bispectra to file. Note Uses a FORMATTED output.","tags":"","loc":"interface\\bsa_exportbisptofile.html"},{"title":"bsa_exportExtremeValuesToFile – BsaLib","text":"interface public module subroutine bsa_exportExtremeValuesToFile(fname, rvar) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: rvar (:) Description Exports extreme (or peak) values to file. Note Uses a FORMATTED output.","tags":"","loc":"interface\\bsa_exportextremevaluestofile.html"},{"title":"bsa_exportModalData – BsaLib","text":"interface public module subroutine bsa_exportModalData() Arguments None Description Exports modal data to file names modal.txt . Note Uses a FORMATTED output. Warning Will be deprecated.","tags":"","loc":"interface\\bsa_exportmodaldata.html"},{"title":"bsa_exportMomentToFile – BsaLib","text":"interface public module subroutine bsa_exportMomentToFile(fname, vec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: vec (:) Description Exports given statistical moments to file. fname is the file name. Note Uses a FORMATTED output.","tags":"","loc":"interface\\bsa_exportmomenttofile.html"},{"title":"bsa_exportPSDToFile – BsaLib","text":"interface public module subroutine bsa_exportPSDToFile(fname, psd, f) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: psd (:,:) real(kind=bsa_real_t), intent(in), optional :: f (:) Description Exports series of PSDs (defined at frequencies f ) to file. Note Uses a FORMATTED output.","tags":"","loc":"interface\\bsa_exportpsdtofile.html"},{"title":"bsa_exportSkewness – BsaLib","text":"public interface bsa_exportSkewness Module Procedures private  interface bsa_exportSkewness_compute_() Arguments None private  interface bsa_exportSkewness_nocompute_() Arguments None","tags":"","loc":"interface\\bsa_exportskewness.html"},{"title":"bsa_forceBsaClsExecution – BsaLib","text":"interface public module subroutine bsa_forceBsaClsExecution(bool) Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool Description Controls the forced execution of a approach.","tags":"","loc":"interface\\bsa_forcebsaclsexecution.html"},{"title":"bsa_generateBSAInputFiles – BsaLib","text":"interface public module subroutine bsa_generateBSAInputFiles(run) Arguments Type Intent Optional Attributes Name logical, value :: run If .false. , exits after files generation.\n Otherwise, keeps running BsaLib normally. Description Enables generation of BSA (built-in executable) compatible input files. This is particularly useful if needing to execute BsaLib in environments\n (e.g. clusters ) where the hosting program/library does not have the (license)\n rights to reside.\n For this exact reason, BsaLib is shipped with its built-in executable,\n that can be easily compiled and run in restricted environments. This routine can be then called to let BsaLib generate the input files\n read by BSA .","tags":"","loc":"interface\\bsa_generatebsainputfiles.html"},{"title":"bsa_getUsedModeShapes – BsaLib","text":"interface public pure module function bsa_getUsedModeShapes() result(modes) Arguments None Return Value integer(kind=bsa_int_t),allocatable,(:) Description Returns a copy of the array of effectively used vibration modes. This is directly linked to bsa_doValidateModalData ,\nor bsa_setKeptModalShapes (even though this last\nAPI call contains the same info, provided by the user).","tags":"","loc":"interface\\bsa_getusedmodeshapes.html"},{"title":"bsa_isCleaned – BsaLib","text":"interface public pure module function bsa_isCleaned() Arguments None Return Value logical Description Query if BsaLib has cleaned ( .true. ) its internal memory, or not ( .false. )","tags":"","loc":"interface\\bsa_iscleaned.html"},{"title":"bsa_isFullComp – BsaLib","text":"interface public elemental module function bsa_isFullComp() result(bool) Arguments None Return Value logical Description Query if a FULL computation is issued.\nBy FULL computation it is meant that all elements of the 2D and 3D tensors of\nSpectra and Bispectra are computed, i.e. both\ndiagonal and outer-diagonal elements.\nIf this API call returns .false. , it means that only diagonal elements of\nsuch tensors are computed ( ONLY_DIAG = .true. ) Warning Issuing a non-FULL computation is indeed good in terms of speed: much less computations required memory: also, much less memory allocated (no need to allocate the whole tensors,\n      if only the diagonal elements are used) On the other hand, non-FULL computations are highly discouraged\nin terms of results accuracy.","tags":"","loc":"interface\\bsa_isfullcomp.html"},{"title":"bsa_printBSAHeader – BsaLib","text":"interface public module subroutine bsa_printBSAHeader() Arguments None Description Prints B.S.A. header to stdout .","tags":"","loc":"interface\\bsa_printbsaheader.html"},{"title":"bsa_saveCoordinatesToFile – BsaLib","text":"interface public module subroutine bsa_saveCoordinatesToFile(fname, coords) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in), optional, target :: coords (:,:) Description Exports nodal coordinates to file Note Uses a FORMATTED output.","tags":"","loc":"interface\\bsa_savecoordinatestofile.html"},{"title":"bsa_setAirDensity – BsaLib","text":"interface public module subroutine bsa_setAirDensity(aird) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), value :: aird Description Specifies a custom value for air density .\nDefaults to .","tags":"","loc":"interface\\bsa_setairdensity.html"},{"title":"bsa_setAnalysisType – BsaLib","text":"interface public module subroutine bsa_setAnalysisType(isuban) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: isuban Description Sets analysis type.\nValid options: \\mathtt{Classic} \\mathtt{Mesher} \\mathtt{Both}","tags":"","loc":"interface\\bsa_setanalysistype.html"},{"title":"bsa_setBRMExportDefaultMode – BsaLib","text":"interface public module subroutine bsa_setBRMExportDefaultMode(imode) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: imode Description Specifies the desired mode of exporting Bispectra (assumes bispectra computation is turned ON). Note Real data is exported as real(real32) from the iso_fortran_env intrinsic module. Warning Contrary to the visual mode (see bsa_enableVisualMode ),\nthis API call enables exporting when actually doing the real computation.\nThat is, in the case of the approach, the Pre-mesh phase is not skipped. All bispectra are exported, so expect to have big files generated.","tags":"","loc":"interface\\bsa_setbrmexportdefaultmode.html"},{"title":"bsa_setBfmMLR – BsaLib","text":"interface public module subroutine bsa_setBfmMLR(bool) Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool Description Set BFM MLR (Multi-Level-Refinement) ON/OFF .\nIf .true. (ON) , exact BFM points are added in the Post-Meshing phase, before actual interpolation steps\nIf .false. (OFF) , no other points than those coming from the Pre-Meshing phase are used.","tags":"","loc":"interface\\bsa_setbfmmlr.html"},{"title":"bsa_setBispExportCallback – BsaLib","text":"interface public module subroutine bsa_setBispExportCallback(fptr) Arguments Type Intent Optional Attributes Name procedure( exportInterf_vect_ ), intent(in), pointer :: fptr Function callback. Description Allows to specify a custom function callback for exporting bispectra.\nApplies to both cases of bsa_enableVisualMode and bsa_setBRMExportDefaultMode","tags":"","loc":"interface\\bsa_setbispexportcallback.html"},{"title":"bsa_setClassicMode – BsaLib","text":"interface public module subroutine bsa_setClassicMode(i_mode) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: i_mode Description Sets computation mode.\nValid options: BSA_CLASSIC_MODE_VECTOR The internal vectorised implementation is used (DEFAULT).\n    This is indeed the preferred option in terms of speed.\n    There is however a limitation of this approach:\n    since it requires a considerable amount of alocated memory,\n    and considered the limit of memory that is requirable to the runtime\n    (before going to unoptimised mechanisms, such swap partition)\n    if a given limit (\\approx 8 Gb) is exceeded, the `BsaLib` runtime\n    automatically switches to a scalar implementation. BSA_CLASSIC_MODE_SCALAR The internal scalar implementation is used.\n    While this implementation is slower than its vectorised counterpart,\n    it is certainly the one to be used to limit memory the footprint.\n    Also, for very big cases, the `BsaLib` runtime might automatically switch\n    to this implementation is too much memory allocation is required.","tags":"","loc":"interface\\bsa_setclassicmode.html"},{"title":"bsa_setExportAppendMode – BsaLib","text":"interface public module subroutine bsa_setExportAppendMode(imode) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: imode Description Warning Deprecated.","tags":"","loc":"interface\\bsa_setexportappendmode.html"},{"title":"bsa_setExportDirectory – BsaLib","text":"interface public module subroutine bsa_setExportDirectory(dirname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname Description Defines a directory to place all the exporting of computed statistical moments,\nwhen invoking any of the related API calls\n(see for instance bsa_exportMomentToFile ).","tags":"","loc":"interface\\bsa_setexportdirectory.html"},{"title":"bsa_setExportFileFormat – BsaLib","text":"interface public module subroutine bsa_setExportFileFormat(iform) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iform Format flag, see BSA_EXPORT_FORMAT_* . Description Defines the desired format (e.g. FORMATTED/UNFORMATTED ) to be used when exporting\nstatistical moments to files.","tags":"","loc":"interface\\bsa_setexportfileformat.html"},{"title":"bsa_setExportInCurrDir – BsaLib","text":"interface public module subroutine bsa_setExportInCurrDir() Arguments None Description Differently from bsa_setExportDirectory ,\nthis API call telss BsaLib to place all exports in the current working directory.","tags":"","loc":"interface\\bsa_setexportincurrdir.html"},{"title":"bsa_setGlobalRotMatW2G – BsaLib","text":"interface public module subroutine bsa_setGlobalRotMatW2G(rotW2G) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: rotW2G (3,3) Description Sets global rotation matrix from WRS to GRS.\nDifferent are the rotation matrices from the local WRS (local to a wind zone), and the GRS.\nFor those, see bsa_setWZRotMatW2G .","tags":"","loc":"interface\\bsa_setglobalrotmatw2g.html"},{"title":"bsa_setIncidenceAngles – BsaLib","text":"interface public module subroutine bsa_setIncidenceAngles(incang) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: incang (:) Description Defines wind mean incidence angle , for each wind zone.","tags":"","loc":"interface\\bsa_setincidenceangles.html"},{"title":"bsa_setKeptModalShapes – BsaLib","text":"interface public module subroutine bsa_setKeptModalShapes(modes) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: modes (:) Description This API call allows to specify a list of vibration modes to be actually accounted for in the computation.\nIt might be tought to directly ask the user to provide only the modes to be used,\nwhen using the bsa_setModalInfo API call.\nHowever, this might limit API flexibility, so that the user is given the chance to\ngive a list of indexes, and restrict the computation to those indexes only,\nwithout requiring to bother to much on how the modal vibration information is given.","tags":"","loc":"interface\\bsa_setkeptmodalshapes.html"},{"title":"bsa_setLoadedNodalDOFs – BsaLib","text":"interface public module subroutine bsa_setLoadedNodalDOFs(libs_l, nlibs_l) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in), target, allocatable :: libs_l (:) Array of loaded nodal DOFs. Note Each array element value must be included in the range\n{[1, \\mathtt{NNDOFs}]}, where is the total\nn. of nodal degrees-of-freedom (see bsa_setNumOfNodalDOFs ). integer(kind=bsa_int_t), optional, value :: nlibs_l N. of passed loaded nodal DOFs. Description Sets number of nodal DOFs effectively loaded ,\nwhere the ending signifies loaded . Note This API call is optional. If not called, BsaLib automatically sets the number of\nloaded nodal DOFs to the maximum, (see bsa_setNumOfNodalDOFs ).","tags":"","loc":"interface\\bsa_setloadednodaldofs.html"},{"title":"bsa_setLoadedNodes – BsaLib","text":"interface public module subroutine bsa_setLoadedNodes(nodes_l, nn_l) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in), target, allocatable :: nodes_l (:) integer(kind=bsa_int_t), optional, value :: nn_l Description Sets number of structural nodes effectively loaded ,\nwhere the ending signifies loaded . Note This API call is optional. If not called, BsaLib automatically sets the number of\nloaded nodes to match all nodes, (see bsa_setTotalNOfNodes ).","tags":"","loc":"interface\\bsa_setloadednodes.html"},{"title":"bsa_setMaxBkgPeakRestriction – BsaLib","text":"interface public module subroutine bsa_setMaxBkgPeakRestriction(bool) Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool Description The width of the background (i.e. quasi-static ) peak is equal to: where is the mean wind speed, the turbulence length scale.\nIn a 3D-spatial turbulence, there in total 9 turbulence scales (lengths),\norganised in a matrix of turbulence scales: By default, If a restriction is applied (i.e. .true. is passed as argument),\nthen the maximum value of the matrix is reduced to the maximum value along the first column:","tags":"","loc":"interface\\bsa_setmaxbkgpeakrestriction.html"},{"title":"bsa_setModalInfo – BsaLib","text":"interface public module subroutine bsa_setModalInfo(ndofs, nm, Phi, natf) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ndofs integer(kind=bsa_int_t), value :: nm real(kind=bsa_real_t), intent(in), target :: Phi (ndofs,nm) real(kind=bsa_real_t), intent(in), target :: natf (nm) Description Provides info about structural modal vibrations.\nNamely, the structural modal matrix (eigenmatrix) Phi and the relative natural frequencies (eigenvalues) natf . Note As a layer of internal verification and correctness checks, this API call forces to specify\ndimensions of the modal matrix (in order).\nUsually, they are the total number of structural degrees-of-freedom (see bsa_setTotalNumOfDOFs )\nand the number of vibration modes.\nIf for any reason, a value mismatch is caught, BsaLib wil throw an internal error.","tags":"","loc":"interface\\bsa_setmodalinfo.html"},{"title":"bsa_setModalMatrices – BsaLib","text":"interface public module subroutine bsa_setModalMatrices(nm, Mgen, Kgen, Cgen) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nm n. of vibration modes Note Should match with the one given in bsa_setModalInfo . real(kind=bsa_real_t), intent(in), target, dimension(nm) :: Mgen real(kind=bsa_real_t), intent(in), target, dimension(nm) :: Kgen real(kind=bsa_real_t), intent(in), target :: Cgen (nm,nm) Description Provides structural modal matrices of mass, stiffness and damping, respectively. Note At the current stage, BsaLib depends on some basic functionalities of\ncommon Finite-Element (FE) software, such as determining the modal matrix of a structure.\nThis choice has been made in order not to bind BsaLib to any specific\nimplementation, and let the final user the choice of the method used to determine these matrices. Warning As per the current implementation, only symmetric modal mass and stiffness matrices are\nconsidered, meaning that in fact, the modal matrix given in bsa_setModalInfo is obtained by solving the\nfollowing Eigenvalue problem: where and are the structural stiffness and mass matrices, a diagonal matrix containing the coefficients of the characteristic\npolynomial equation.\nIn such cases, the resulting modal mass and stiffness matrices will be diagonalised by .\nTherefore, only the diagonal elements are required by BsaLib .","tags":"","loc":"interface\\bsa_setmodalmatrices.html"},{"title":"bsa_setNodalCoords – BsaLib","text":"interface public module subroutine bsa_setNodalCoords(nn, coords) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nn total number of nodes. real(kind=bsa_real_t), target, contiguous :: coords (:,:) Dimensions [3, nn] , where 3 refers to the 3 spatial\ndirections . Description Provides nodal spatial coordinates.","tags":"","loc":"interface\\bsa_setnodalcoords.html"},{"title":"bsa_setNodalVel – BsaLib","text":"interface public module subroutine bsa_setNodalVel(Unod) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: Unod (:) Description Provides mean wind speeds at all structural nodes . Note If this API call is made, then all the wind characteristics info (e.g. turbulence scales, turbulence intensities, etc.)\nare not needed, since they serve computing the final nodal wind speeds, which\nthis API call provides already. Warning Currently, wind speeds at all nodes must be given, even if\nnot all of them are actually under the wind lading action.\nInfo on which nodes are effectively loaded is needed, so that internally,\nthe distinction can be done. Warning Will be deprecated","tags":"","loc":"interface\\bsa_setnodalvel.html"},{"title":"bsa_setNodalWindAltitudes – BsaLib","text":"interface public module subroutine bsa_setNodalWindAltitudes(WnodAlt) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: WnodAlt (:) Description Sets altitude for each node. Warning In a later implementation, this should be internally deferred based on\nthe selected vertical wind axis, and nodal coordinates. Warning Will be deprecated","tags":"","loc":"interface\\bsa_setnodalwindaltitudes.html"},{"title":"bsa_setNodalWindZones – BsaLib","text":"interface public module subroutine bsa_setNodalWindZones(NodWZ) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in), target :: NodWZ (:) Description Provides info on each node's wind zone. That is, in which wind zone each node is located. Warning Will be deprecated","tags":"","loc":"interface\\bsa_setnodalwindzones.html"},{"title":"bsa_setNumOfNodalDOFs – BsaLib","text":"interface public module subroutine bsa_setNumOfNodalDOFs(nndofs) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nndofs Description Sets number of total degrees-of-freedom per node .","tags":"","loc":"interface\\bsa_setnumofnodaldofs.html"},{"title":"bsa_setOutFileName – BsaLib","text":"interface public module subroutine bsa_setOutFileName(fname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Description Warning Deprecated.","tags":"","loc":"interface\\bsa_setoutfilename.html"},{"title":"bsa_setOutUnit – BsaLib","text":"interface public module subroutine bsa_setOutUnit(iunit) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iunit Description Sets unit to be used for the output file.\nUseful if needed to use an already opened unit from hosting program unit.","tags":"","loc":"interface\\bsa_setoutunit.html"},{"title":"bsa_setOutputDirectory – BsaLib","text":"interface public module subroutine bsa_setOutputDirectory(dirname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname Description Sets output directory.","tags":"","loc":"interface\\bsa_setoutputdirectory.html"},{"title":"bsa_setPODNOfModesKept – BsaLib","text":"interface public module subroutine bsa_setPODNOfModesKept(nmodes) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nmodes number of POD modes ( ), with number of effectively loaded nodes. Description Contrary to bsa_setPODTruncationThreshold , this API call sets the desired number of\nPOD modes to be kept in the truncation procedure. Warning To make this API call effective, please make sure to not call bsa_setPODTruncationThreshold as well, since that call would automatically invalidate this one (higher precedence).","tags":"","loc":"interface\\bsa_setpodnofmodeskept.html"},{"title":"bsa_setPODTruncationThreshold – BsaLib","text":"interface public module subroutine bsa_setPODTruncationThreshold(rval) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), value :: rval Energy threshold limit, in the range .\nIf 0 is passed, all energy is kept (i.e. no truncation, as ).\nIf is passed in the range , it is automatically rescaled\nto the absolute range . Description Sets the threshold limit of total energy to be kept in the truncation of POD modes,\nwhen decomposing the Cross-Spectral-Density-Matrix of base turbulence . Warning If invoking this API call, a call to bsa_setPODNOfModesKept will be automatically\ninvalidated, since this API call has higher precedence (more accurate, specifies energy content).","tags":"","loc":"interface\\bsa_setpodtruncationthreshold.html"},{"title":"bsa_setPSDType – BsaLib","text":"interface public module subroutine bsa_setPSDType(ipsd) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ipsd Description Sets base wind turbulence PSD (Power Spectral Density).\nValid options: BSA_WIND_PSD_VONKARMAN : VonKarman spectum: BSA_WIND_PSD_KAIMAL : Kaimal spectrum BSA_WIND_PSD_DAVENPORT : Davenport spectrum","tags":"","loc":"interface\\bsa_setpsdtype.html"},{"title":"bsa_setPhitimesC – BsaLib","text":"interface public module subroutine bsa_setPhitimesC(phiTc) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: phiTc (:,:,:) Description Warning Will be deprecated","tags":"","loc":"interface\\bsa_setphitimesc.html"},{"title":"bsa_setPolicyIDValidationValues – BsaLib","text":"interface public module subroutine bsa_setPolicyIDValidationValues(id, i_bfm, j_bfm, i_brm, j_brm) Arguments Type Intent Optional Attributes Name integer(kind=int32), value :: id Built-in POlicy ID integer(kind=int32), value :: i_bfm BFM i-direction validation factor integer(kind=int32), value :: j_bfm BFM j-direction validation factor integer(kind=int32), value :: i_brm BRM i-direction validation factor integer(kind=int32), value :: j_brm BRM j-direction validation factor Description Allows to set custom delta validation values for a given built-in Policy ID. Note This API call has effect if delta validation is set to ON via the bsa_doValidateZoneDeltas API call.\nendnote","tags":"","loc":"interface\\bsa_setpolicyidvalidationvalues.html"},{"title":"bsa_setPremeshMode – BsaLib","text":"interface public module subroutine bsa_setPremeshMode(imode) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: imode Description Sets Pre-mesh mode.\nValid options: BSA_PREMESH_MODE_BASE (0) BSA_PREMESH_MODE_ZONE_REFINED (1) (DEFAULT)","tags":"","loc":"interface\\bsa_setpremeshmode.html"},{"title":"bsa_setPremeshScheme – BsaLib","text":"interface public module subroutine bsa_setPremeshScheme(itype) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: itype Description Set Pre-mesh Scheme.\nValid options: BSA_PREMESH_TYPE_DIAG_CREST_NO (0) :  No zones to cover Diagonal crests in 2-4 quadrants\n       (DEFAULT) BSA_PREMESH_TYPE_DIAG_CREST_YES (1) :  Diagonal crests in 2-4 quadrants are explicitly meshed Warning itype = 1 is highly NOTrecommended as per the current implementation.","tags":"","loc":"interface\\bsa_setpremeshscheme.html"},{"title":"bsa_setScalingConv – BsaLib","text":"interface public module subroutine bsa_setScalingConv(iconv) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iconv Description Set Power-Spectral-Density (PSD) integration convention.\nThere are two fundamental integration conventions: The frequency convention ( BSA_PSD_CONVENTION_FREQ ),\n   where the integral of the PSD from 0 to +\\infty gives the variance\n    m_2 = \\sigma&#94;2 = \\int_0&#94;{+\\infty} S(f) df.  The pulsation convention ( BSA_PSD_CONVENTION_PULS ),\n   where the integral of the PSD from -\\infty to +\\infty gives the variance\n    m_2 = \\sigma&#94;2 = \\int_{-\\infty}&#94;{+\\infty} S(\\omega) d\\omega.  Note By DEFAULT, BsaLib uses the convention on pulsations ( BSA_PSD_CONVENTION_FREQ ).","tags":"","loc":"interface\\bsa_setscalingconv.html"},{"title":"bsa_setSpatialNodalCorr – BsaLib","text":"interface public module subroutine bsa_setSpatialNodalCorr(nodCorr) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: nodCorr (:,:) Description Warning Will be deprecated","tags":"","loc":"interface\\bsa_setspatialnodalcorr.html"},{"title":"bsa_setSpatialSymmetry – BsaLib","text":"interface public module subroutine bsa_setSpatialSymmetry(isym) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: isym Description Sets spatial symmetry value.\nValid options are: BSA_SPATIAL_SYM_NONE (0) : NONE , full space computed  (DEFAULT) BSA_SPATIAL_SYM_HALF (2) : HALF space computed. BSA_SPATIAL_SYM_FOUR (4) : 1-FOURTH space computed.","tags":"","loc":"interface\\bsa_setspatialsymmetry.html"},{"title":"bsa_setSpectraComputation – BsaLib","text":"interface public module subroutine bsa_setSpectraComputation(ipsd, ibisp) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ipsd If , activates computation of Spectra ( order statisitcs) integer(kind=bsa_int_t), value :: ibisp If , activates computation of Bispectra ( order statisitcs) Description Gives control on which kind of spectral features are computed.","tags":"","loc":"interface\\bsa_setspectracomputation.html"},{"title":"bsa_setSpectraExtension – BsaLib","text":"interface public module subroutine bsa_setSpectraExtension(ionlydiag) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ionlydiag Description Sets extension of statistical information.\nThere are two possible scenarios: FULL All elements of the 2D and 3D tensors of Spectra and Bispectra are computed.\n    This is indeed the most accurate analysis. ONLY_DIAG Only elements of the main diagonal are computed.\n    While this approach is faster, and consumes much less memory, it is not\n    recommended for results accuracy issues. Note By DEFAULT, BsaLib performs a FULL analysis.","tags":"","loc":"interface\\bsa_setspectraextension.html"},{"title":"bsa_setSpectraSymmetries – BsaLib","text":"interface public module subroutine bsa_setSpectraSymmetries(ispctrsym) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ispctrsym Description Controls whether Spectra and Bispectra (tensorial) symmetries are exploited, or not.\nIn many cases, specially when the loading process is a real process,\nspectal tensors of Spectra and Bispectra are symmetric with respect to their main diagonal, that is: where represents the set of all permutations of the 3 indexes, taken in groups of 3. NO  (0) :  no tensor-elements symmetry is used NONE , full space computed  (DEFAULT) YES (1) :  tensor-elements symetry is used.\n      This means that approximately \\frac{N}{2} elements of the 2D trensor of Spectra,\n      and approximately \\frac{N}{6} elements of the 3D tensor of Bispectra are effectively computed,\n      where N is the characteristic dimension of the square tensors (both 2D and 3D). Note For the case of tensor of Bispectra, if spatial symmetry is set to BSA_SPATIAL_SYM_FOUR bsa_setSpatialSymmetry ,\ntensor-elements symmetry is automatically disabled.","tags":"","loc":"interface\\bsa_setspectrasymmetries.html"},{"title":"bsa_setTestMode – BsaLib","text":"interface public module subroutine bsa_setTestMode(itest) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: itest Description Enables testing mode. Warning If testing mode is enabled, some important features and checks are turned OFF.\nUse with care.","tags":"","loc":"interface\\bsa_settestmode.html"},{"title":"bsa_setTotDamping – BsaLib","text":"interface public module subroutine bsa_setTotDamping(xsi) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: xsi (:) Description Provides modal damping ratios . Note This should include any possible source of damping, from structural damping\nto aerodynamic damping in case of wind loading, etc.","tags":"","loc":"interface\\bsa_settotdamping.html"},{"title":"bsa_setTotalNOfNodes – BsaLib","text":"interface public module subroutine bsa_setTotalNOfNodes(nn) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nn Description Sets number of total structural nodes .","tags":"","loc":"interface\\bsa_settotalnofnodes.html"},{"title":"bsa_setTotalNumOfDOFs – BsaLib","text":"interface public module subroutine bsa_setTotalNumOfDOFs(ndofs) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ndofs Description Provides the total number of structural degrees-of-freedom . where is the total number of structural nodes, the number of degrees-of-freedom per node.","tags":"","loc":"interface\\bsa_settotalnumofdofs.html"},{"title":"bsa_setTurbWindSDT – BsaLib","text":"interface public module subroutine bsa_setTurbWindSDT(sigma) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: sigma (3,*) Description Defines wind turbulence standard deviation , for each wind zone.\nThis is directly linked to the turbulence intensity , defined as:","tags":"","loc":"interface\\bsa_setturbwindsdt.html"},{"title":"bsa_setTurbWindScales – BsaLib","text":"interface public module subroutine bsa_setTurbWindScales(L) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: L (3,3,*) Description Defines wind turbulence scales for each wind zone.","tags":"","loc":"interface\\bsa_setturbwindscales.html"},{"title":"bsa_setVersion – BsaLib","text":"interface public module subroutine bsa_setVersion(ivers) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ivers Description Warning Deprecated.","tags":"","loc":"interface\\bsa_setversion.html"},{"title":"bsa_setVisualIndexes – BsaLib","text":"interface public module subroutine bsa_setVisualIndexes(indexes, modal) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: indexes (3) Array of indexes.\nSpecify indexing combination of the bispectra to be exported.\nResulting index value is computed as: modal: i = id_1 + id_2*\\mathtt{M} + id_3*\\mathtt{M}&#94;2\n      where id_i \\in [1, \\dots, \\mathtt{M}], \\mathtt{M}= n. of kept modes. nodal: i = (id_1 - 1)*\\mathtt{NNDOFs} + id_2\n      where id_1 refers to the node index,\n      id_2 to the nodal degree-of-freedom index,\n      \\mathtt{NNDOFs} being the total number of nodal degrees-of-freedom. Note In the modal case, if ONLY_DIAG is .true. (i.e. only the elements on the main tensor diagonal are computed),\nthe index is computed as simply logical, value :: modal If .true. , indicates to export modal response bispectra.\nOtherwise, nodal bispectra is exported. Note In a future implementation, other kinds of response bispectra could be allowed to\nbe exported (internal efforts, support reactions, etc.) Description","tags":"","loc":"interface\\bsa_setvisualindexes.html"},{"title":"bsa_setWZMeanWindVel – BsaLib","text":"interface public module subroutine bsa_setWZMeanWindVel(mat) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: mat (:) Description Defines mean wind speeds , for each wind zone.","tags":"","loc":"interface\\bsa_setwzmeanwindvel.html"},{"title":"bsa_setWZRefAlt – BsaLib","text":"interface public module subroutine bsa_setWZRefAlt(Zref) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: Zref (:) Description Defines reference altitudes , for each wind zone.","tags":"","loc":"interface\\bsa_setwzrefalt.html"},{"title":"bsa_setWZRotMatW2G – BsaLib","text":"interface public module subroutine bsa_setWZRotMatW2G(rotW2G_L) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: rotW2G_L (3,3,*) Description Defines the rotation matrix from the wind zone's local wind reference system (WRSl), to the global one (GRS).\nThis to allow different principal wind flow directions for each wond zone.","tags":"","loc":"interface\\bsa_setwzrotmatw2g.html"},{"title":"bsa_setWindAltDir – BsaLib","text":"interface public module subroutine bsa_setWindAltDir(ivert) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ivert Axis index, with value among one of . Description Specifies which of the 3 Euclidean axes of the Wind Reference coordinate System\nis to be accounted as vertical axis. Note This is an important detail, which affect how altitudes and so wind speeds\nare determined.","tags":"","loc":"interface\\bsa_setwindaltdir.html"},{"title":"bsa_setWindCorrCoeffs – BsaLib","text":"interface public module subroutine bsa_setWindCorrCoeffs(ccoeffs) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: ccoeffs (3,3,*) Description Defines the coefficients used in the decreasing-exponential formulation of wind spatial coherence.","tags":"","loc":"interface\\bsa_setwindcorrcoeffs.html"},{"title":"bsa_setWindCorrExpnts – BsaLib","text":"interface public module subroutine bsa_setWindCorrExpnts(cexpn) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: cexpn (3,3,*) Description Defines the exponent coefficients used in the decreasing-exponential formulation of wind spatial coherence.","tags":"","loc":"interface\\bsa_setwindcorrexpnts.html"},{"title":"bsa_setWindDirections – BsaLib","text":"interface public module subroutine bsa_setWindDirections(dirs, ndirs) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: dirs (:) integer(kind=bsa_int_t), optional, value :: ndirs","tags":"","loc":"interface\\bsa_setwinddirections.html"},{"title":"bsa_setWindFCoeffs – BsaLib","text":"interface public module subroutine bsa_setWindFCoeffs(wfc) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: wfc (:,:,:) Dimensions should be [nlibs_l, ndegw+3, nnodes_l] Description Warning Will be deprecated","tags":"","loc":"interface\\bsa_setwindfcoeffs.html"},{"title":"bsa_setWindTurbComps – BsaLib","text":"interface public module subroutine bsa_setWindTurbComps(tc, ntc) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: tc (:) Array of components. Each array element value should\nbe equal to one of . integer(kind=bsa_int_t), optional, value :: ntc total n. of turbulent components to consider. Description Specifies which turbulent components, among , should be considered\nin the definition of wind loads, and for which PSDs will be computed.","tags":"","loc":"interface\\bsa_setwindturbcomps.html"},{"title":"bsa_setWindVertProf – BsaLib","text":"interface public module subroutine bsa_setWindVertProf(iwprof) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iwprof Description Sets the wind vertical profile.\nValid options: BSA_WIND_VERT_PROFILE_POWER : uses a power law\n         \\overline{U}(z) = \\left({\\frac{z}{z_{ref}}}\\right)&#94;{\\alpha}  BSA_WIND_VERT_PROFILE_LOG : uses a logarithmic law\n         \\overline{U}(z) = {\\frac{1}{k}}\\sqrt{\\frac{\\tau_0}{\\rho}}\\ln{\\frac{z}{z_0}} ","tags":"","loc":"interface\\bsa_setwindvertprof.html"},{"title":"bsa_setWindZoneLimits – BsaLib","text":"interface public module subroutine bsa_setWindZoneLimits(lim, ilim) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: lim (..) integer(kind=bsa_int_t), intent(in), optional :: ilim (..) Description Sets limits defining wind zones.\nIn real cases, if the structural system spans long distances horizontally (bridges), or vertically (skyscrapers),\nit might happen that the wind characteristics (wind speed, turbulence scales, etc.) change, so that\napplying a unique wind all along would be physically incorrect.\nTo do so, more than one wind zone can be defined, to provide differentiation of wind characteristics along the structure. Warning Limits are usually considered to be defined along the X-axis of the\nGlobal Reference coordinate System (GRS), assuming horizontal structural\nsystems, such as long-span bridges.\nIn a later implementation, freedom to choose on which axis defining the wind\nzones MUST be given, for flexibility and correctness reasons.","tags":"","loc":"interface\\bsa_setwindzonelimits.html"},{"title":"bsa_setupClassic – BsaLib","text":"interface public module subroutine bsa_setupClassic(nfreqs, df) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nfreqs number of discretisation points (i.e. n. of frequencies) Note Refers to the interval .\nIf the pulsations convention is used ( BSA_PSD_CONVENTION_PULS ),\nthen this number will be automatically actualised to the interval . real(kind=bsa_real_t), value :: df Spacing between discretisation points (i.e. delta ) Description Main setup data for the approach. Warning If testing mode is OFF, these values might be internally modified in order to\nmeet some minimum accuracy requirements.","tags":"","loc":"interface\\bsa_setupclassic.html"},{"title":"bsa_setupMesher – BsaLib","text":"interface public module subroutine bsa_setupMesher(isvd, bkgrfmt, bkgaext, genpaext, maxaext, ifcov, idumpmod) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: isvd If 1 , enables use of POD techniques to decompose\nCross-Spectral-Density-Matrices of base wind turbulence. integer(kind=bsa_int_t), value :: bkgrfmt Defines the base n. of refinement points used to mesh the\nbackground (quasi-static) zone, placed at the origin . Note Several other zones' discretisation depend on this value. real(kind=bsa_real_t), value :: bkgaext Defines the factor by which the background zone is extended.\nThis is done to allow the user extending this zone, avoiding cutting\nthe zone's extensions where gradients are still important.\nActs as a safety factor. real(kind=bsa_real_t), value :: genpaext Defines the factor by which the any peak zone is extended.\nSame reasons as for the background zone. real(kind=bsa_real_t), value :: maxaext Defines the factor by which the total covered area is extended.\nIn this case, this is done to avoid loosing information coming from the\nsecondary peaks, which are usually placed at extensions up to ,\nwhere is the th modal frequency. integer(kind=bsa_int_t), value :: ifcov Warning Deprecated integer(kind=bsa_int_t), value :: idumpmod If 1 , includes modal data in the dumpfile . Note While it is not optimal in terms of disk usage,\nit is certainly recommended in order to keep needed information all in one place. Description Main setup data for the approach.","tags":"","loc":"interface\\bsa_setupmesher.html"},{"title":"BsaLib – BsaLib","text":"This file is part of BsaLib.\nCopyright (C) 2024  Michele Esposito Marzino BsaLib is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version. BsaLib is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details. You should have received a copy of the GNU General Public License\nalong with BsaLib.  If not, see https://www.gnu.org/licenses/ . Uses iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: BRM_EXPORT_FNAME_CLS = 'bsaexport_cls.brm' character(len=*), public, parameter :: BRM_EXPORT_FNAME_MSH = 'bsaexport_msh.brm' character(len=*), public, parameter :: BRN_EXPORT_FNAME_CLS = 'bsaexport_cls.brn' character(len=*), public, parameter :: BRN_EXPORT_FNAME_MSH = 'bsaexport_msh.brn' integer(kind=IK), public, parameter :: BSA_CLASSIC_MODE_SCALAR = 1_IK integer(kind=IK), public, parameter :: BSA_CLASSIC_MODE_VECTOR = 0_IK character(len=*), public, parameter :: BSA_DATA_FNAME = \"bsa.bsadata\" integer(kind=IK), public, parameter :: BSA_EXPORT_BRM_MODE_BASE = 1_IK integer(kind=IK), public, parameter :: BSA_EXPORT_BRM_MODE_NONE = 0_IK integer(kind=IK), public, parameter :: BSA_EXPORT_BRM_MODE_USR = 9_IK integer(kind=IK), public, parameter :: BSA_EXPORT_FORMAT_FORMATTED = 0_IK integer(kind=IK), public, parameter :: BSA_EXPORT_FORMAT_UNFORMATTED = 1_IK character(len=*), public, parameter :: BSA_EXPORT_M2MF_CLS_FNAME = \"m2mf_cls\" character(len=*), public, parameter :: BSA_EXPORT_M2MF_MSH_FNAME = \"m2mf_msh\" character(len=*), public, parameter :: BSA_EXPORT_M2MR_CLS_FNAME = \"m2mr_cls\" character(len=*), public, parameter :: BSA_EXPORT_M2MR_MSH_FNAME = \"m2mr_msh\" character(len=*), public, parameter :: BSA_EXPORT_M2O2MR_CLS_FNAME = \"m2o2mr_cls\" character(len=*), public, parameter :: BSA_EXPORT_M2O2MR_MSH_FNAME = \"m2o2mr_msh\" character(len=*), public, parameter :: BSA_EXPORT_M3MF_CLS_FNAME = \"m3mf_cls\" character(len=*), public, parameter :: BSA_EXPORT_M3MF_MSH_FNAME = \"m3mf_msh\" character(len=*), public, parameter :: BSA_EXPORT_M3MR_CLS_FNAME = \"m3mr_cls\" character(len=*), public, parameter :: BSA_EXPORT_M3MR_MSH_FNAME = \"m3mr_msh\" integer(kind=IK), public, parameter :: BSA_EXPORT_MODE_APPEND = 1_IK integer(kind=IK), public, parameter :: BSA_EXPORT_MODE_REPLACE = 0_IK character(len=0), public, parameter :: BSA_FILE_NAME_CL_SUFFIX = '' character(len=*), public, parameter :: BSA_OUT_DIRNAME_DEFAULT = '.\\bsaresults\\' character(len=*), public, parameter :: BSA_OUT_FILENAME_PREFIX_DEFAULT_ = 'bsaout_def' integer(kind=IK), public, parameter :: BSA_PREMESH_MODE_BASE = 0_IK integer(kind=IK), public, parameter :: BSA_PREMESH_MODE_ZONE_REFINED = 1_IK integer(kind=IK), public, parameter :: BSA_PREMESH_TYPE_DIAG_CREST_NO = 0_IK integer(kind=IK), public, parameter :: BSA_PREMESH_TYPE_DIAG_CREST_YES = 1_IK integer(kind=IK), public, parameter :: BSA_PSD_CONVENTION_FREQ = 0_IK integer(kind=IK), public, parameter :: BSA_PSD_CONVENTION_PULS = 1_IK integer(kind=IK), public, parameter :: BSA_SPATIAL_SYM_FOUR = 4_IK integer(kind=IK), public, parameter :: BSA_SPATIAL_SYM_HALF = 2_IK integer(kind=IK), public, parameter :: BSA_SPATIAL_SYM_NONE = 0_IK integer(kind=IK), public, parameter :: BSA_WIND_PSD_DAVENPORT = 5_IK integer(kind=IK), public, parameter :: BSA_WIND_PSD_KAIMAL = 2_IK integer(kind=IK), public, parameter :: BSA_WIND_PSD_VONKARMAN = 1_IK integer(kind=IK), public, parameter :: BSA_WIND_VERT_PROFILE_LOG = 2_IK integer(kind=IK), public, parameter :: BSA_WIND_VERT_PROFILE_POWER = 1_IK real(kind=RK), public, parameter :: CST_2d3 = 2.0_RK/3.0_RK real(kind=RK), public, parameter :: CST_3d2 = 3.0_RK/2.0_RK real(kind=RK), public, parameter :: CST_PIGREC = 4.0_RK*atan(1.0_RK) real(kind=RK), public, parameter :: CST_PId2 = CST_PIGREC/2.0_RK real(kind=RK), public, parameter :: CST_PId4 = CST_PIGREC/4.0_RK real(kind=RK), public, parameter :: CST_PIt2 = CST_PIGREC*2.0_RK real(kind=RK), public, parameter :: CST_PIt3d2 = CST_PIGREC*CST_3d2 real(kind=RK), public, parameter :: CST_PIt4 = CST_PIGREC*4.0_RK character(len=*), public, parameter :: DBGMSG = '  --[debug]  ' character(len=*), public, parameter :: ERRMSG = '  --[error]  ' character(len=*), public, parameter :: EXT_DATA_FNAME = \"bsa.extdata\" integer, public, parameter :: IK = int32 character(len=*), public, parameter :: INFOMSG = '  --[info]   ' character(len=*), public, parameter :: IO_ACCESS_APPEND = 'APPEND' character(len=*), public, parameter :: IO_ACCESS_DIRECT = 'DIRECT' character(len=*), public, parameter :: IO_ACCESS_SEQUEN = 'SEQUENTIAL' character(len=*), public, parameter :: IO_ACCESS_STREAM = 'STREAM' character(len=*), public, parameter :: IO_ACTION_READ = 'READ' character(len=*), public, parameter :: IO_ACTION_READWRITE = 'READWRITE' character(len=*), public, parameter :: IO_ACTION_WRITE = 'WRITE' character(len=*), public, parameter :: IO_ASYNC_NO = 'NO' character(len=*), public, parameter :: IO_ASYNC_YES = 'YES' character(len=*), public, parameter :: IO_FORM_BINARY = 'BINARY' character(len=*), public, parameter :: IO_FORM_FORMATTED = 'FORMATTED' character(len=*), public, parameter :: IO_FORM_UNFORMATTED = 'UNFORMATTED' character(len=*), public, parameter :: IO_POSITION_APPEND = 'APPEND' character(len=*), public, parameter :: IO_POSITION_ASIS = 'ASIS' character(len=*), public, parameter :: IO_POSITION_REWIND = 'REWIND' character(len=*), public, parameter :: IO_STATUS_NEW = 'NEW' character(len=*), public, parameter :: IO_STATUS_OLD = 'OLD' character(len=*), public, parameter :: IO_STATUS_REPLACE = 'REPLACE' character(len=*), public, parameter :: IO_STATUS_SCRATCH = 'SCRATCH' character(len=*), public, parameter :: IO_STATUS_UNKNOWN = 'UNKNOWN' real(kind=RK), public, parameter :: MACHINE_PRECISION = 1e-12_RK Note To avoid assertion errors in Mesher due to sin() / cos() intrinsic functions\n rounding errors. character(len=*), public, parameter :: MSGCONT = '             ' character(len=*), public, parameter :: NOTEMSG = '  --[note]   ' integer, public, parameter :: RK = real64 character(len=*), public, parameter :: WARNMSG = '  --[warn]   ' integer, public, parameter :: bsa_int_t = IK integer, public, parameter :: bsa_real_t = RK Interfaces interface public module subroutine bsa_Finalise() Once BsaLib has finished, call this API procedure to ensure the cleanup of internal memory. Arguments None interface public module subroutine bsa_Init() Initialises BsaLib runtime internals Arguments None interface public module subroutine bsa_Run(m2mf_cls, m2mr_cls, m2o2mr_cls, m3mf_msh, m3mr_msh, m3mf_cls, m3mr_cls) Main BsaLib procedure.\nThis should be the last API call to make, after all settings has been done.\nAt return, post-processing API calls can be done to export/elaborate results. Note For any argument that is not desired (provided that internal settings are compatible),\na null() argument can be passed. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), target, allocatable, dimension(:) :: m2mf_cls order moments, modal forces, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m2mr_cls order moments, modal responses, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m2o2mr_cls order spectral moments, modal responses, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mf_msh order moments, modal forces, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mr_msh order moments, modal responses, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mf_cls order moments, modal forces, approach real(kind=bsa_real_t), target, allocatable, dimension(:) :: m3mr_cls order moments, modal responses, approach interface public module subroutine bsa_closeUnitsAtEnd() If called, tells BsaLib to close internal unit handles at exit.\nThis is not a wanted behaviour if, for example, output unit is taken from\nhosting program unit (see bsa_setOutUnit ),\nand might be used even after BsaLib returns from main ( bsa_Run ). Arguments None interface public module subroutine bsa_computeBRdecomp(m2mf, bkg, res) Returns the Background-Resonant decomposition, given the second order statistical moments of the modal loads. Note This is an API call to be used in a post-processing phase. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: m2mf (:) real(kind=bsa_real_t), intent(out), allocatable :: bkg (:) real(kind=bsa_real_t), intent(out), allocatable :: res (:) interface public module subroutine bsa_computePeakFactors(m2, m2o2, obs_time, peak_g, sk, peak_ng_pos, peak_ng_neg) Computes Gaussian and Non-Gaussian Peak factors.\nFormulations are taken from CITE!. Note This is an API call to be used in a post-processing phase. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: m2 (:) real(kind=bsa_real_t), intent(in) :: m2o2 (:) real(kind=bsa_real_t), intent(in) :: obs_time real(kind=bsa_real_t), intent(inout), allocatable :: peak_g (:) real(kind=bsa_real_t), intent(in), allocatable :: sk (:) real(kind=bsa_real_t), intent(inout), allocatable :: peak_ng_pos (:) real(kind=bsa_real_t), intent(inout), optional, allocatable :: peak_ng_neg (:) interface public module subroutine bsa_doValidateModalData(bool) Enables (or disables, default option) validation of modal (structural) data. Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool If .false. (DEFAULT), do not perform any modal data validation.\n If .true. , checks if some modes in the structural modal matrix are not 1-normalised, and removes them from the effectively kept modes.\n This is to avoid having statistical moments of modal responses that are not computed\n with the same normalisation across all vibration modes (e.g. vertical and torsional modes). Bug As per the current implementation, all non 1-normalised modes are discarded.\nHowever, this might not be the desired behaviour, if for example, modes are\nnormalised with a criteria different than the 1-normalisation approach,\nor if only torsional modes (which are usually normalised to rotations and not displacements)\nare to be considered.\nA fix is certainly needed to remove this limitation. interface public module subroutine bsa_doValidateZoneDeltas(bool) If .true. is given, enables zone's deltas validation. Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool interface public module subroutine bsa_enableGPU() Enables GPU code. Arguments None interface public module subroutine bsa_enableOnlyPremesh() If called, exits after Pre-mesh phase. Skips Post-mesh. Arguments None interface public module subroutine bsa_enableVisualMode() Enables visual mode.\n Visual mode allows the user to write bispectra of modal/nodal responses.\n When in visual mode, Pre-mesh phase is skipped, and data read from file ( dumpfile ).\n Only the Post-mesh phase is done (mostly interpolation ), and data written to files. Arguments None public        interface bsa_exportBRdecomp private  interface bsa_exportBR_nocompute_() Arguments None interface public module subroutine bsa_exportBispToFile(fname, bisp) Exports series of Bispectra to file. Note Uses a FORMATTED output. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: bisp (:,:,:) interface public module subroutine bsa_exportExtremeValuesToFile(fname, rvar) Exports extreme (or peak) values to file. Note Uses a FORMATTED output. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: rvar (:) interface public module subroutine bsa_exportModalData() Exports modal data to file names modal.txt . Note Uses a FORMATTED output. Warning Will be deprecated. Arguments None interface public module subroutine bsa_exportMomentToFile(fname, vec) Exports given statistical moments to file. fname is the file name. Note Uses a FORMATTED output. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: vec (:) interface public module subroutine bsa_exportPSDToFile(fname, psd, f) Exports series of PSDs (defined at frequencies f ) to file. Note Uses a FORMATTED output. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in) :: psd (:,:) real(kind=bsa_real_t), intent(in), optional :: f (:) public        interface bsa_exportSkewness private  interface bsa_exportSkewness_compute_() Arguments None private  interface bsa_exportSkewness_nocompute_() Arguments None interface public module subroutine bsa_forceBsaClsExecution(bool) Controls the forced execution of a approach. Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool interface public module subroutine bsa_generateBSAInputFiles(run) Enables generation of BSA (built-in executable) compatible input files. This is particularly useful if needing to execute BsaLib in environments\n (e.g. clusters ) where the hosting program/library does not have the (license)\n rights to reside.\n For this exact reason, BsaLib is shipped with its built-in executable,\n that can be easily compiled and run in restricted environments. This routine can be then called to let BsaLib generate the input files\n read by BSA . Arguments Type Intent Optional Attributes Name logical, value :: run If .false. , exits after files generation.\n Otherwise, keeps running BsaLib normally. interface public pure module function bsa_getUsedModeShapes() result(modes) Returns a copy of the array of effectively used vibration modes. This is directly linked to bsa_doValidateModalData ,\nor bsa_setKeptModalShapes (even though this last\nAPI call contains the same info, provided by the user). Arguments None Return Value integer(kind=bsa_int_t), allocatable, (:) interface public pure module function bsa_isCleaned() Query if BsaLib has cleaned ( .true. ) its internal memory, or not ( .false. ) Arguments None Return Value logical interface public elemental module function bsa_isFullComp() result(bool) Query if a FULL computation is issued.\nBy FULL computation it is meant that all elements of the 2D and 3D tensors of\nSpectra and Bispectra are computed, i.e. both\ndiagonal and outer-diagonal elements.\nIf this API call returns .false. , it means that only diagonal elements of\nsuch tensors are computed ( ONLY_DIAG = .true. ) Warning Issuing a non-FULL computation is indeed good in terms of speed: much less computations required memory: also, much less memory allocated (no need to allocate the whole tensors,\n      if only the diagonal elements are used) On the other hand, non-FULL computations are highly discouraged\nin terms of results accuracy. Arguments None Return Value logical interface public module subroutine bsa_printBSAHeader() Prints B.S.A. header to stdout . Arguments None interface public module subroutine bsa_saveCoordinatesToFile(fname, coords) Exports nodal coordinates to file Note Uses a FORMATTED output. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname real(kind=bsa_real_t), intent(in), optional, target :: coords (:,:) interface public module subroutine bsa_setAirDensity(aird) Specifies a custom value for air density .\nDefaults to . Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), value :: aird interface public module subroutine bsa_setAnalysisType(isuban) Sets analysis type.\nValid options: \\mathtt{Classic} \\mathtt{Mesher} \\mathtt{Both} Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: isuban interface public module subroutine bsa_setBRMExportDefaultMode(imode) Specifies the desired mode of exporting Bispectra (assumes bispectra computation is turned ON). Note Real data is exported as real(real32) from the iso_fortran_env intrinsic module. Warning Contrary to the visual mode (see bsa_enableVisualMode ),\nthis API call enables exporting when actually doing the real computation.\nThat is, in the case of the approach, the Pre-mesh phase is not skipped. All bispectra are exported, so expect to have big files generated. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: imode interface public module subroutine bsa_setBfmMLR(bool) Set BFM MLR (Multi-Level-Refinement) ON/OFF .\nIf .true. (ON) , exact BFM points are added in the Post-Meshing phase, before actual interpolation steps\nIf .false. (OFF) , no other points than those coming from the Pre-Meshing phase are used. Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool interface public module subroutine bsa_setBispExportCallback(fptr) Allows to specify a custom function callback for exporting bispectra.\nApplies to both cases of bsa_enableVisualMode and bsa_setBRMExportDefaultMode Arguments Type Intent Optional Attributes Name procedure( exportInterf_vect_ ), intent(in), pointer :: fptr Function callback. interface public module subroutine bsa_setClassicMode(i_mode) Sets computation mode.\nValid options: BSA_CLASSIC_MODE_VECTOR The internal vectorised implementation is used (DEFAULT).\n    This is indeed the preferred option in terms of speed.\n    There is however a limitation of this approach:\n    since it requires a considerable amount of alocated memory,\n    and considered the limit of memory that is requirable to the runtime\n    (before going to unoptimised mechanisms, such swap partition)\n    if a given limit (\\approx 8 Gb) is exceeded, the `BsaLib` runtime\n    automatically switches to a scalar implementation. BSA_CLASSIC_MODE_SCALAR The internal scalar implementation is used.\n    While this implementation is slower than its vectorised counterpart,\n    it is certainly the one to be used to limit memory the footprint.\n    Also, for very big cases, the `BsaLib` runtime might automatically switch\n    to this implementation is too much memory allocation is required. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: i_mode interface public module subroutine bsa_setExportAppendMode(imode) Warning Deprecated. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: imode interface public module subroutine bsa_setExportDirectory(dirname) Defines a directory to place all the exporting of computed statistical moments,\nwhen invoking any of the related API calls\n(see for instance bsa_exportMomentToFile ). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname interface public module subroutine bsa_setExportFileFormat(iform) Defines the desired format (e.g. FORMATTED/UNFORMATTED ) to be used when exporting\nstatistical moments to files. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iform Format flag, see BSA_EXPORT_FORMAT_* . interface public module subroutine bsa_setExportInCurrDir() Differently from bsa_setExportDirectory ,\nthis API call telss BsaLib to place all exports in the current working directory. Arguments None interface public module subroutine bsa_setGlobalRotMatW2G(rotW2G) Sets global rotation matrix from WRS to GRS.\nDifferent are the rotation matrices from the local WRS (local to a wind zone), and the GRS.\nFor those, see bsa_setWZRotMatW2G . Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: rotW2G (3,3) interface public module subroutine bsa_setIncidenceAngles(incang) Defines wind mean incidence angle , for each wind zone. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: incang (:) interface public module subroutine bsa_setKeptModalShapes(modes) This API call allows to specify a list of vibration modes to be actually accounted for in the computation.\nIt might be tought to directly ask the user to provide only the modes to be used,\nwhen using the bsa_setModalInfo API call.\nHowever, this might limit API flexibility, so that the user is given the chance to\ngive a list of indexes, and restrict the computation to those indexes only,\nwithout requiring to bother to much on how the modal vibration information is given. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: modes (:) interface public module subroutine bsa_setLoadedNodalDOFs(libs_l, nlibs_l) Sets number of nodal DOFs effectively loaded ,\nwhere the ending signifies loaded . Note This API call is optional. If not called, BsaLib automatically sets the number of\nloaded nodal DOFs to the maximum, (see bsa_setNumOfNodalDOFs ). Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in), target, allocatable :: libs_l (:) Array of loaded nodal DOFs. Note Each array element value must be included in the range\n{[1, \\mathtt{NNDOFs}]}, where is the total\nn. of nodal degrees-of-freedom (see bsa_setNumOfNodalDOFs ). integer(kind=bsa_int_t), optional, value :: nlibs_l N. of passed loaded nodal DOFs. interface public module subroutine bsa_setLoadedNodes(nodes_l, nn_l) Sets number of structural nodes effectively loaded ,\nwhere the ending signifies loaded . Note This API call is optional. If not called, BsaLib automatically sets the number of\nloaded nodes to match all nodes, (see bsa_setTotalNOfNodes ). Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in), target, allocatable :: nodes_l (:) integer(kind=bsa_int_t), optional, value :: nn_l interface public module subroutine bsa_setMaxBkgPeakRestriction(bool) The width of the background (i.e. quasi-static ) peak is equal to: where is the mean wind speed, the turbulence length scale.\nIn a 3D-spatial turbulence, there in total 9 turbulence scales (lengths),\norganised in a matrix of turbulence scales: By default, If a restriction is applied (i.e. .true. is passed as argument),\nthen the maximum value of the matrix is reduced to the maximum value along the first column: Arguments Type Intent Optional Attributes Name logical, intent(in) :: bool interface public module subroutine bsa_setModalInfo(ndofs, nm, Phi, natf) Provides info about structural modal vibrations.\nNamely, the structural modal matrix (eigenmatrix) Phi and the relative natural frequencies (eigenvalues) natf . Note As a layer of internal verification and correctness checks, this API call forces to specify\ndimensions of the modal matrix (in order).\nUsually, they are the total number of structural degrees-of-freedom (see bsa_setTotalNumOfDOFs )\nand the number of vibration modes.\nIf for any reason, a value mismatch is caught, BsaLib wil throw an internal error. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ndofs integer(kind=bsa_int_t), value :: nm real(kind=bsa_real_t), intent(in), target :: Phi (ndofs,nm) real(kind=bsa_real_t), intent(in), target :: natf (nm) interface public module subroutine bsa_setModalMatrices(nm, Mgen, Kgen, Cgen) Provides structural modal matrices of mass, stiffness and damping, respectively. Note At the current stage, BsaLib depends on some basic functionalities of\ncommon Finite-Element (FE) software, such as determining the modal matrix of a structure.\nThis choice has been made in order not to bind BsaLib to any specific\nimplementation, and let the final user the choice of the method used to determine these matrices. Warning As per the current implementation, only symmetric modal mass and stiffness matrices are\nconsidered, meaning that in fact, the modal matrix given in bsa_setModalInfo is obtained by solving the\nfollowing Eigenvalue problem: where and are the structural stiffness and mass matrices, a diagonal matrix containing the coefficients of the characteristic\npolynomial equation.\nIn such cases, the resulting modal mass and stiffness matrices will be diagonalised by .\nTherefore, only the diagonal elements are required by BsaLib . Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nm n. of vibration modes Note Should match with the one given in bsa_setModalInfo . real(kind=bsa_real_t), intent(in), target, dimension(nm) :: Mgen real(kind=bsa_real_t), intent(in), target, dimension(nm) :: Kgen real(kind=bsa_real_t), intent(in), target :: Cgen (nm,nm) interface public module subroutine bsa_setNodalCoords(nn, coords) Provides nodal spatial coordinates. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nn total number of nodes. real(kind=bsa_real_t), target, contiguous :: coords (:,:) Dimensions [3, nn] , where 3 refers to the 3 spatial\ndirections . interface public module subroutine bsa_setNodalVel(Unod) Provides mean wind speeds at all structural nodes . Note If this API call is made, then all the wind characteristics info (e.g. turbulence scales, turbulence intensities, etc.)\nare not needed, since they serve computing the final nodal wind speeds, which\nthis API call provides already. Warning Currently, wind speeds at all nodes must be given, even if\nnot all of them are actually under the wind lading action.\nInfo on which nodes are effectively loaded is needed, so that internally,\nthe distinction can be done. Warning Will be deprecated Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: Unod (:) interface public module subroutine bsa_setNodalWindAltitudes(WnodAlt) Sets altitude for each node. Warning In a later implementation, this should be internally deferred based on\nthe selected vertical wind axis, and nodal coordinates. Warning Will be deprecated Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: WnodAlt (:) interface public module subroutine bsa_setNodalWindZones(NodWZ) Provides info on each node's wind zone. That is, in which wind zone each node is located. Warning Will be deprecated Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in), target :: NodWZ (:) interface public module subroutine bsa_setNumOfNodalDOFs(nndofs) Sets number of total degrees-of-freedom per node . Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nndofs interface public module subroutine bsa_setOutFileName(fname) Warning Deprecated. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname interface public module subroutine bsa_setOutUnit(iunit) Sets unit to be used for the output file.\nUseful if needed to use an already opened unit from hosting program unit. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iunit interface public module subroutine bsa_setOutputDirectory(dirname) Sets output directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname interface public module subroutine bsa_setPODNOfModesKept(nmodes) Contrary to bsa_setPODTruncationThreshold , this API call sets the desired number of\nPOD modes to be kept in the truncation procedure. Warning To make this API call effective, please make sure to not call bsa_setPODTruncationThreshold as well, since that call would automatically invalidate this one (higher precedence). Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nmodes number of POD modes ( ), with number of effectively loaded nodes. interface public module subroutine bsa_setPODTruncationThreshold(rval) Sets the threshold limit of total energy to be kept in the truncation of POD modes,\nwhen decomposing the Cross-Spectral-Density-Matrix of base turbulence . Warning If invoking this API call, a call to bsa_setPODNOfModesKept will be automatically\ninvalidated, since this API call has higher precedence (more accurate, specifies energy content). Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), value :: rval Energy threshold limit, in the range .\nIf 0 is passed, all energy is kept (i.e. no truncation, as ).\nIf is passed in the range , it is automatically rescaled\nto the absolute range . interface public module subroutine bsa_setPSDType(ipsd) Sets base wind turbulence PSD (Power Spectral Density).\nValid options: BSA_WIND_PSD_VONKARMAN : VonKarman spectum: BSA_WIND_PSD_KAIMAL : Kaimal spectrum BSA_WIND_PSD_DAVENPORT : Davenport spectrum Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ipsd interface public module subroutine bsa_setPhitimesC(phiTc) Warning Will be deprecated Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: phiTc (:,:,:) interface public module subroutine bsa_setPolicyIDValidationValues(id, i_bfm, j_bfm, i_brm, j_brm) Allows to set custom delta validation values for a given built-in Policy ID. Note This API call has effect if delta validation is set to ON via the bsa_doValidateZoneDeltas API call.\nendnote Arguments Type Intent Optional Attributes Name integer(kind=int32), value :: id Built-in POlicy ID integer(kind=int32), value :: i_bfm BFM i-direction validation factor integer(kind=int32), value :: j_bfm BFM j-direction validation factor integer(kind=int32), value :: i_brm BRM i-direction validation factor integer(kind=int32), value :: j_brm BRM j-direction validation factor interface public module subroutine bsa_setPremeshMode(imode) Sets Pre-mesh mode.\nValid options: BSA_PREMESH_MODE_BASE (0) BSA_PREMESH_MODE_ZONE_REFINED (1) (DEFAULT) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: imode interface public module subroutine bsa_setPremeshScheme(itype) Set Pre-mesh Scheme.\nValid options: BSA_PREMESH_TYPE_DIAG_CREST_NO (0) :  No zones to cover Diagonal crests in 2-4 quadrants\n       (DEFAULT) BSA_PREMESH_TYPE_DIAG_CREST_YES (1) :  Diagonal crests in 2-4 quadrants are explicitly meshed Warning itype = 1 is highly NOTrecommended as per the current implementation. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: itype interface public module subroutine bsa_setScalingConv(iconv) Set Power-Spectral-Density (PSD) integration convention.\nThere are two fundamental integration conventions: The frequency convention ( BSA_PSD_CONVENTION_FREQ ),\n   where the integral of the PSD from 0 to +\\infty gives the variance\n    m_2 = \\sigma&#94;2 = \\int_0&#94;{+\\infty} S(f) df.  The pulsation convention ( BSA_PSD_CONVENTION_PULS ),\n   where the integral of the PSD from -\\infty to +\\infty gives the variance\n    m_2 = \\sigma&#94;2 = \\int_{-\\infty}&#94;{+\\infty} S(\\omega) d\\omega.  Note By DEFAULT, BsaLib uses the convention on pulsations ( BSA_PSD_CONVENTION_FREQ ). Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iconv interface public module subroutine bsa_setSpatialNodalCorr(nodCorr) Warning Will be deprecated Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: nodCorr (:,:) interface public module subroutine bsa_setSpatialSymmetry(isym) Sets spatial symmetry value.\nValid options are: BSA_SPATIAL_SYM_NONE (0) : NONE , full space computed  (DEFAULT) BSA_SPATIAL_SYM_HALF (2) : HALF space computed. BSA_SPATIAL_SYM_FOUR (4) : 1-FOURTH space computed. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: isym interface public module subroutine bsa_setSpectraComputation(ipsd, ibisp) Gives control on which kind of spectral features are computed. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ipsd If , activates computation of Spectra ( order statisitcs) integer(kind=bsa_int_t), value :: ibisp If , activates computation of Bispectra ( order statisitcs) interface public module subroutine bsa_setSpectraExtension(ionlydiag) Sets extension of statistical information.\nThere are two possible scenarios: FULL All elements of the 2D and 3D tensors of Spectra and Bispectra are computed.\n    This is indeed the most accurate analysis. ONLY_DIAG Only elements of the main diagonal are computed.\n    While this approach is faster, and consumes much less memory, it is not\n    recommended for results accuracy issues. Note By DEFAULT, BsaLib performs a FULL analysis. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ionlydiag interface public module subroutine bsa_setSpectraSymmetries(ispctrsym) Controls whether Spectra and Bispectra (tensorial) symmetries are exploited, or not.\nIn many cases, specially when the loading process is a real process,\nspectal tensors of Spectra and Bispectra are symmetric with respect to their main diagonal, that is: where represents the set of all permutations of the 3 indexes, taken in groups of 3. NO  (0) :  no tensor-elements symmetry is used NONE , full space computed  (DEFAULT) YES (1) :  tensor-elements symetry is used.\n      This means that approximately \\frac{N}{2} elements of the 2D trensor of Spectra,\n      and approximately \\frac{N}{6} elements of the 3D tensor of Bispectra are effectively computed,\n      where N is the characteristic dimension of the square tensors (both 2D and 3D). Note For the case of tensor of Bispectra, if spatial symmetry is set to BSA_SPATIAL_SYM_FOUR bsa_setSpatialSymmetry ,\ntensor-elements symmetry is automatically disabled. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ispctrsym interface public module subroutine bsa_setTestMode(itest) Enables testing mode. Warning If testing mode is enabled, some important features and checks are turned OFF.\nUse with care. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: itest interface public module subroutine bsa_setTotDamping(xsi) Provides modal damping ratios . Note This should include any possible source of damping, from structural damping\nto aerodynamic damping in case of wind loading, etc. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: xsi (:) interface public module subroutine bsa_setTotalNOfNodes(nn) Sets number of total structural nodes . Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nn interface public module subroutine bsa_setTotalNumOfDOFs(ndofs) Provides the total number of structural degrees-of-freedom . where is the total number of structural nodes, the number of degrees-of-freedom per node. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ndofs interface public module subroutine bsa_setTurbWindSDT(sigma) Defines wind turbulence standard deviation , for each wind zone.\nThis is directly linked to the turbulence intensity , defined as: Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: sigma (3,*) interface public module subroutine bsa_setTurbWindScales(L) Defines wind turbulence scales for each wind zone. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: L (3,3,*) interface public module subroutine bsa_setVersion(ivers) Warning Deprecated. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ivers interface public module subroutine bsa_setVisualIndexes(indexes, modal) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: indexes (3) Array of indexes.\nSpecify indexing combination of the bispectra to be exported.\nResulting index value is computed as: modal: i = id_1 + id_2*\\mathtt{M} + id_3*\\mathtt{M}&#94;2\n      where id_i \\in [1, \\dots, \\mathtt{M}], \\mathtt{M}= n. of kept modes. nodal: i = (id_1 - 1)*\\mathtt{NNDOFs} + id_2\n      where id_1 refers to the node index,\n      id_2 to the nodal degree-of-freedom index,\n      \\mathtt{NNDOFs} being the total number of nodal degrees-of-freedom. Note In the modal case, if ONLY_DIAG is .true. (i.e. only the elements on the main tensor diagonal are computed),\nthe index is computed as simply logical, value :: modal If .true. , indicates to export modal response bispectra.\nOtherwise, nodal bispectra is exported. Note In a future implementation, other kinds of response bispectra could be allowed to\nbe exported (internal efforts, support reactions, etc.) interface public module subroutine bsa_setWZMeanWindVel(mat) Defines mean wind speeds , for each wind zone. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: mat (:) interface public module subroutine bsa_setWZRefAlt(Zref) Defines reference altitudes , for each wind zone. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: Zref (:) interface public module subroutine bsa_setWZRotMatW2G(rotW2G_L) Defines the rotation matrix from the wind zone's local wind reference system (WRSl), to the global one (GRS).\nThis to allow different principal wind flow directions for each wond zone. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: rotW2G_L (3,3,*) interface public module subroutine bsa_setWindAltDir(ivert) Specifies which of the 3 Euclidean axes of the Wind Reference coordinate System\nis to be accounted as vertical axis. Note This is an important detail, which affect how altitudes and so wind speeds\nare determined. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: ivert Axis index, with value among one of . interface public module subroutine bsa_setWindCorrCoeffs(ccoeffs) Defines the coefficients used in the decreasing-exponential formulation of wind spatial coherence. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: ccoeffs (3,3,*) interface public module subroutine bsa_setWindCorrExpnts(cexpn) Defines the exponent coefficients used in the decreasing-exponential formulation of wind spatial coherence. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: cexpn (3,3,*) interface public module subroutine bsa_setWindDirections(dirs, ndirs) Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: dirs (:) integer(kind=bsa_int_t), optional, value :: ndirs interface public module subroutine bsa_setWindFCoeffs(wfc) Warning Will be deprecated Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in), target :: wfc (:,:,:) Dimensions should be [nlibs_l, ndegw+3, nnodes_l] interface public module subroutine bsa_setWindTurbComps(tc, ntc) Specifies which turbulent components, among , should be considered\nin the definition of wind loads, and for which PSDs will be computed. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), intent(in) :: tc (:) Array of components. Each array element value should\nbe equal to one of . integer(kind=bsa_int_t), optional, value :: ntc total n. of turbulent components to consider. interface public module subroutine bsa_setWindVertProf(iwprof) Sets the wind vertical profile.\nValid options: BSA_WIND_VERT_PROFILE_POWER : uses a power law\n         \\overline{U}(z) = \\left({\\frac{z}{z_{ref}}}\\right)&#94;{\\alpha}  BSA_WIND_VERT_PROFILE_LOG : uses a logarithmic law\n         \\overline{U}(z) = {\\frac{1}{k}}\\sqrt{\\frac{\\tau_0}{\\rho}}\\ln{\\frac{z}{z_0}}  Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: iwprof interface public module subroutine bsa_setWindZoneLimits(lim, ilim) Sets limits defining wind zones.\nIn real cases, if the structural system spans long distances horizontally (bridges), or vertically (skyscrapers),\nit might happen that the wind characteristics (wind speed, turbulence scales, etc.) change, so that\napplying a unique wind all along would be physically incorrect.\nTo do so, more than one wind zone can be defined, to provide differentiation of wind characteristics along the structure. Warning Limits are usually considered to be defined along the X-axis of the\nGlobal Reference coordinate System (GRS), assuming horizontal structural\nsystems, such as long-span bridges.\nIn a later implementation, freedom to choose on which axis defining the wind\nzones MUST be given, for flexibility and correctness reasons. Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: lim (..) integer(kind=bsa_int_t), intent(in), optional :: ilim (..) interface public module subroutine bsa_setupClassic(nfreqs, df) Main setup data for the approach. Warning If testing mode is OFF, these values might be internally modified in order to\nmeet some minimum accuracy requirements. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: nfreqs number of discretisation points (i.e. n. of frequencies) Note Refers to the interval .\nIf the pulsations convention is used ( BSA_PSD_CONVENTION_PULS ),\nthen this number will be automatically actualised to the interval . real(kind=bsa_real_t), value :: df Spacing between discretisation points (i.e. delta ) interface public module subroutine bsa_setupMesher(isvd, bkgrfmt, bkgaext, genpaext, maxaext, ifcov, idumpmod) Main setup data for the approach. Arguments Type Intent Optional Attributes Name integer(kind=bsa_int_t), value :: isvd If 1 , enables use of POD techniques to decompose\nCross-Spectral-Density-Matrices of base wind turbulence. integer(kind=bsa_int_t), value :: bkgrfmt Defines the base n. of refinement points used to mesh the\nbackground (quasi-static) zone, placed at the origin . Note Several other zones' discretisation depend on this value. real(kind=bsa_real_t), value :: bkgaext Defines the factor by which the background zone is extended.\nThis is done to allow the user extending this zone, avoiding cutting\nthe zone's extensions where gradients are still important.\nActs as a safety factor. real(kind=bsa_real_t), value :: genpaext Defines the factor by which the any peak zone is extended.\nSame reasons as for the background zone. real(kind=bsa_real_t), value :: maxaext Defines the factor by which the total covered area is extended.\nIn this case, this is done to avoid loosing information coming from the\nsecondary peaks, which are usually placed at extensions up to ,\nwhere is the th modal frequency. integer(kind=bsa_int_t), value :: ifcov Warning Deprecated integer(kind=bsa_int_t), value :: idumpmod If 1 , includes modal data in the dumpfile . Note While it is not optimal in terms of disk usage,\nit is certainly recommended in order to keep needed information all in one place. Abstract Interfaces abstract interface public  subroutine exportInterf_vect_(f1, f2, brm, pdata) Arguments Type Intent Optional Attributes Name real(kind=bsa_real_t), intent(in) :: f1 (:) Array of frequencies along the X-axis real(kind=bsa_real_t), intent(in) :: f2 (:) Array of frequencies along the Y-axis real(kind=bsa_real_t), intent(in) :: brm (:,:) Data of bispectra class(*), intent(in), pointer :: pdata Unlimited polymorphic object allowinf the user to pass any kind of\nobject, holding the necessary data to be used when backfiring the\nprovided callback function when exporting bispectra information.","tags":"","loc":"module\\bsalib.html"},{"title":"BsaLib.F90 – BsaLib","text":"This file is part of BsaLib.\nCopyright (C) 2024  Michele Esposito Marzino BsaLib is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version. BsaLib is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details. You should have received a copy of the GNU General Public License\nalong with BsaLib. If not, see https://www.gnu.org/licenses/ . Source Code !! This file is part of BsaLib. !! Copyright (C) 2024  Michele Esposito Marzino !! !! BsaLib is free software: you can redistribute it and/or modify !! it under the terms of the GNU General Public License as published by !! the Free Software Foundation, either version 3 of the License, or !! (at your option) any later version. !! !! BsaLib is distributed in the hope that it will be useful, !! but WITHOUT ANY WARRANTY; without even the implied warranty of !! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !! GNU General Public License for more details. !! !! You should have received a copy of the GNU General Public License !! along with BsaLib. If not, see <https://www.gnu.org/licenses/>. module BsaLib !! author: Michele Esposito Marzino !! version: 0.1.0 use , intrinsic :: iso_fortran_env implicit none ( type , external ) public #include \"_CONSTANTS.F90\" interface bsa_exportBRdecomp module procedure bsa_exportBR_nocompute_ end interface interface bsa_exportSkewness module procedure bsa_exportSkewness_compute_ module procedure bsa_exportSkewness_nocompute_ end interface ! ************************************************************************************** !    INTERAFCE FOR  PUBLIC  PROCEDURES ! ************************************************************************************** interface ! ************************************** !    GENERAL ! ************************************** module subroutine bsa_printBSAHeader () !! Prints  `B.S.A.`  header to `stdout`. end subroutine module subroutine bsa_enableGPU () !! Enables GPU code. end subroutine module subroutine bsa_setSpatialSymmetry ( isym ) !# <span style=\"white-space: pre-line\"> ! Sets spatial symmetry value. ! Valid options are: ! <ul> !    <li> <code>BSA_SPATIAL_SYM_NONE (0)</code>:  <i>NONE</i>, full space computed  (DEFAULT)</li> !    <li> <code>BSA_SPATIAL_SYM_HALF (2)</code>:  <i>HALF</i> space computed.</li> !    <li> <code>BSA_SPATIAL_SYM_FOUR (4)</code>:  <i>1-FOURTH</i> space computed.</li> ! </ul> ! </span> integer ( bsa_int_t ), value :: isym end subroutine module subroutine bsa_setSpectraSymmetries ( ispctrsym ) !# <span style=\"white-space: pre-line\"> ! Controls whether Spectra and Bispectra (tensorial) symmetries are exploited, or not. ! In many cases, specially when the loading process is a real process, ! spectal tensors of Spectra and Bispectra are symmetric with respect to their main diagonal, that is: !   B_{ijk}(\\omega_1,\\omega_2) \\equiv !       B_{kji}(\\omega_1,\\omega_2) \\quad \\forall \\{k, j, i\\} \\in \\mathrm{P}(3, 3),  !  where \\mathrm{P}(3, 3) represents the set of all permutations of the 3 indexes, taken in groups of 3. ! <ol> !    <li> <code>NO  (0)</code>:  no tensor-elements symmetry is used <i>NONE</i>, full space computed  (DEFAULT)</li> !    <li> <code>YES (1)</code>:  tensor-elements symetry is used. !       This means that approximately \\frac{N}{2} elements of the 2D trensor of Spectra, !       and approximately \\frac{N}{6} elements of the 3D tensor of Bispectra are effectively computed, !       where N is the characteristic dimension of the square tensors (both 2D and 3D). !       </li> ! </ol> ! ! @note ! For the case of tensor of Bispectra, if spatial symmetry is set to ! <code>BSA_SPATIAL_SYM_FOUR [[bsalib(module):bsa_setspatialsymmetry(interface)]]</code>, ! tensor-elements symmetry is automatically disabled. ! <span> integer ( bsa_int_t ), value :: ispctrsym end subroutine module subroutine bsa_setPremeshScheme ( itype ) !# <span style=\"white-space: pre-line\"> ! Set Pre-mesh Scheme. ! Valid options: ! <ul> !   <li> <code>BSA_PREMESH_TYPE_DIAG_CREST_NO (0)</code>:  No zones to cover Diagonal crests in 2-4 quadrants !        (DEFAULT)</li> !   <li> <code>BSA_PREMESH_TYPE_DIAG_CREST_YES (1)</code>:  Diagonal crests in 2-4 quadrants are explicitly meshed</li> ! </ul> ! ! @warning ! <code>itype = 1</code>  is <b>highly NOTrecommended</b>  as per the current implementation. ! @endwarning ! </span> integer ( bsa_int_t ), value :: itype end subroutine module subroutine bsa_setPremeshMode ( imode ) !# <span style=\"white-space: pre-line\"> ! Sets Pre-mesh mode. ! Valid options: ! <ul> !   <li><code>BSA_PREMESH_MODE_BASE (0)</code></li> !   <li><code>BSA_PREMESH_MODE_ZONE_REFINED (1)</code>  (DEFAULT)</li> ! </ul> !  </span> integer ( bsa_int_t ), value :: imode end subroutine module subroutine bsa_enableVisualMode () !# <span style=\"white-space: pre-line\"> !  Enables <i>visual</i> mode. !  Visual mode allows the user to write bispectra of modal/nodal responses. !  When in visual mode, Pre-mesh phase is skipped, and data read from file (<code>dumpfile</code>). !  Only the Post-mesh phase is done (mostly <i>interpolation</i>), and data written to files. !  </span> end subroutine module subroutine bsa_generateBSAInputFiles ( run ) !# <span style=\"white-space: pre-line\"> !  Enables generation of <code>BSA</code> (built-in executable) compatible input files. ! !  This is particularly useful if needing to execute <code>BsaLib</code> in environments !  (e.g. <i>clusters</i>) where the hosting program/library does not have the (license) !  rights to reside. !  For this exact reason, <code>BsaLib</code> is shipped with its built-in executable, !  that can be easily compiled and run in restricted environments. ! !  This routine can be then called to let <code>BsaLib</code> generate the input files !  read by <code>BSA</code>. ! !  </span> logical , value :: run !# If <code>.false.</code>, exits after files generation. !  Otherwise, keeps running <code>BsaLib</code> normally. end subroutine module subroutine bsa_setVisualIndexes ( indexes , modal ) !# <span style=\"white-space: pre-line\"> ! !  </span> integer ( bsa_int_t ), intent ( in ) :: indexes ( 3 ) !# <span style=\"white-space: pre-line\"> ! Array of indexes. ! Specify indexing combination of the bispectra to be exported. ! Resulting index i value is computed as: ! <ul type=\"1\"> !   <li>modal: i = id_1 + id_2*\\mathtt{M} + id_3*\\mathtt{M}&#94;2 !       where id_i \\in [1, \\dots, \\mathtt{M}], \\mathtt{M}= n. of kept modes. !   </li> !   <li>nodal: i = (id_1 - 1)*\\mathtt{NNDOFs} + id_2 !       where id_1 refers to the <i>node</i> index, !       id_2 to the nodal <i>degree-of-freedom</i> index, !       \\mathtt{NNDOFs} being the total number of nodal degrees-of-freedom. !   </li> ! </ul> ! ! @note ! In the modal case, if <code>ONLY_DIAG</code> is <code>.true.</code> ! (i.e. only the elements on the main tensor diagonal are computed), ! the index is computed as simply  i = id_1  ! @endnote !  </span> logical , value :: modal !# <span style=\"white-space: pre-line\"> ! If <code>.true.</code>, indicates to export <i>modal</i> response bispectra. ! Otherwise, <i>nodal</i> bispectra is exported. ! ! @note ! In a future implementation, other kinds of response bispectra could be allowed to ! be exported (internal efforts, support reactions, etc.) ! @endnote ! </span> end subroutine module subroutine bsa_enableOnlyPremesh () !! If called, exits after Pre-mesh phase. Skips Post-mesh. end subroutine module subroutine bsa_doValidateModalData ( bool ) !# <span style=\"white-space: pre-line\"> !  Enables (or disables, default option) validation of modal (structural) data. ! </span> logical , intent ( in ) :: bool !# <span style=\"white-space: pre-line\"> !  If <code>.false.</code> (DEFAULT), do not perform any modal data validation. !  If <code>.true.</code>, checks if some modes in the structural modal matrix \\boldsymbol{\\Phi} !  are not 1-normalised, and removes them from the <i>effectively kept</i> modes. !  This is to avoid having statistical moments of modal responses that are not computed !  with the same normalisation across all vibration modes (e.g. vertical and torsional modes). ! ! @bug ! As per the current implementation, all non 1-normalised modes are discarded. ! However, this might not be the desired behaviour, if for example, modes are ! normalised with a criteria different than the 1-normalisation approach, ! or if only torsional modes (which are usually normalised to rotations and not displacements) ! are to be considered. ! A fix is certainly needed to remove this limitation. ! @endbug ! </span> end subroutine module subroutine bsa_doValidateZoneDeltas ( bool ) !# <span style=\"white-space: pre-line\"> ! If <code>.true.</code> is given, enables zone's deltas validation. ! </span> logical , intent ( in ) :: bool end subroutine module subroutine bsa_setPolicyIDValidationValues ( id , i_bfm , j_bfm , i_brm , j_brm ) !# <span style=\"white-space: pre-line\"> ! Allows to set custom delta validation values for a given built-in Policy ID. ! ! @note ! This API call has effect if delta validation is set to ON via the ! <code>[[bsalib(module):bsa_dovalidatezonedeltas(interface)]]</code> API call. ! endnote ! </span> integer ( int32 ), value :: id !! Built-in POlicy ID integer ( int32 ), value :: i_bfm !! BFM i-direction validation factor integer ( int32 ), value :: j_bfm !! BFM j-direction validation factor integer ( int32 ), value :: i_brm !! BRM i-direction validation factor integer ( int32 ), value :: j_brm !! BRM j-direction validation factor end subroutine module subroutine bsa_setBfmMLR ( bool ) !# <span style=\"white-space: pre-line\"> ! Set BFM MLR (Multi-Level-Refinement) <code>ON/OFF</code>. ! If <code>.true. (ON)</code>, exact BFM points are added in the Post-Meshing phase, before actual interpolation steps ! If <code>.false. (OFF)</code>, no other points than those coming from the Pre-Meshing phase are used. ! </span> logical , intent ( in ) :: bool end subroutine module subroutine bsa_Init () !! Initialises `BsaLib` runtime internals end subroutine module subroutine bsa_forceBsaClsExecution ( bool ) !# <span style=\"white-space: pre-line\"> ! Controls the forced execution of a \\mathtt{Classic} approach. ! </span> logical , intent ( in ) :: bool end subroutine module subroutine bsa_setMaxBkgPeakRestriction ( bool ) !# <span style=\"white-space: pre-line\"> ! The width of the background (i.e. <i>quasi-static</i>) peak is equal to: !  W_{\\mathrm{bkg}} = \\frac{\\overline{U}}{L} \\quad \\mathrm{[Hz]} ! where \\overline{U} is the mean wind speed, L the turbulence length scale. ! In a 3D-spatial turbulence, there in total 9 turbulence scales (lengths), ! organised in a 3 \\times 3 matrix of turbulence scales: !  \\mathbf{L} = !    \\begin{Bmatrix} !       \\mathbf{l}_1 && \\mathbf{l}_2 && \\mathbf{l}_3 !    \\end{Bmatrix} = !    \\begin{Bmatrix} !       L_{ux} && L_{vx} && L_{wx}\\\\L_{uy} && L_{vy} && L_{wy}\\\\L_{uz} && L_{vz} && L_{wz} !    \\end{Bmatrix}  ! By default,  L = \\mathrm{maxval}(\\mathbf{L}).  ! If a restriction is applied (i.e. <code>.true.</code> is passed as argument), ! then the maximum value of the matrix is reduced to the maximum value along the first column: !   L = \\mathrm{maxval}(\\mathbf{l}_1)  ! </span> logical , intent ( in ) :: bool end subroutine module subroutine bsa_setPODTruncationThreshold ( rval ) !# <span style=\"white-space: pre-line\"> ! Sets the threshold limit r_{lim} of total energy to be kept in the truncation of POD modes, ! when decomposing the Cross-Spectral-Density-Matrix of base turbulence \\mathbf{S}(\\omega). ! ! @warning ! If invoking this API call, a call to <code>[[bsalib(module):bsa_setpodnofmodeskept(interface)]]</code> will be automatically ! invalidated, since this API call has higher precedence (more accurate, specifies energy content). ! </span> real ( bsa_real_t ), value :: rval !! Energy threshold limit, in the range \\mathtt{rval} \\in [0, \\dots, 1] . !! If `0` is passed, all energy is kept (i.e. no truncation, as \\mathtt{rval} = 1). !! If \\mathtt{rval} is passed in the range [0, \\dots, 100]\\%, it is automatically rescaled !! to the absolute range [0, \\dots, 1]. end subroutine module subroutine bsa_setPODNOfModesKept ( nmodes ) !# <span style=\"white-space: pre-line\"> ! Contrary to <code>[[bsalib(module):bsa_setpodtruncationthreshold(interface)]]</code>, this API call sets the desired number of ! POD modes to be kept in the truncation procedure. ! ! @warning ! To make this API call effective, please make sure to not call ! <code>[[bsalib(module):bsa_setpodtruncationthreshold(interface)]]</code> ! as well, since that call would automatically invalidate this one (higher precedence). ! </span> integer ( bsa_int_t ), value :: nmodes !! number of POD modes (\\le \\mathtt{NNL}), with \\mathtt{NNL} !! number of effectively loaded nodes. end subroutine module subroutine bsa_Run ( m2mf_cls , m2mr_cls , m2o2mr_cls , m3mf_msh , m3mr_msh , m3mf_cls , m3mr_cls ) !# <span style=\"white-space: pre-line\"> ! <b>Main</b> `BsaLib` procedure. ! This should be the <b>last</b> API call to make, after all settings has been done. ! At return, post-processing API calls can be done to export/elaborate results. ! ! @note ! For any argument that is not desired (provided that internal settings are compatible), ! a <code>null()</code> argument can be passed. ! </span> real ( bsa_real_t ), target , allocatable , dimension (:) :: m2mf_cls !! 2&#94;{\\mathrm{nd}} order moments, modal forces, \\mathtt{Classic} approach real ( bsa_real_t ), target , allocatable , dimension (:) :: m2mr_cls !! 2&#94;{\\mathrm{nd}} order moments, modal responses, \\mathtt{Classic} approach real ( bsa_real_t ), target , allocatable , dimension (:) :: m2o2mr_cls !! 2&#94;{\\mathrm{nd}} order spectral moments, modal responses, \\mathtt{Classic} approach real ( bsa_real_t ), target , allocatable , dimension (:) :: m3mf_msh !! 3&#94;{\\mathrm{rd}} order moments, modal forces, \\mathtt{Mesher} approach real ( bsa_real_t ), target , allocatable , dimension (:) :: m3mr_msh !! 3&#94;{\\mathrm{rd}} order moments, modal responses, \\mathtt{Mesher} approach real ( bsa_real_t ), target , allocatable , dimension (:) :: m3mf_cls !! 3&#94;{\\mathrm{rd}} order moments, modal forces, \\mathtt{Classic} approach real ( bsa_real_t ), target , allocatable , dimension (:) :: m3mr_cls !! 3&#94;{\\mathrm{rd}} order moments, modal responses, \\mathtt{Classic} approach end subroutine module subroutine bsa_Finalise () !! Once `BsaLib` has finished, call this API procedure to ensure the cleanup of internal memory. end subroutine logical pure module function bsa_isCleaned () !! Query if `BsaLib` has cleaned (<code>.true.</code>) its internal memory, or not (<code>.false.</code>) end function ! ************************************** !    SETTINGS ! ************************************** elemental module function bsa_isFullComp () result ( bool ) !# <span style=\"white-space: pre-line\"> ! Query if a FULL computation is issued. ! By FULL computation it is meant that all elements of the 2D and 3D tensors of ! Spectra \\mathbf{S} and Bispectra \\mathbf{B} are computed, i.e. both ! diagonal and outer-diagonal elements. ! If this API call returns <code>.false.</code>, it means that only diagonal elements of ! such tensors are computed (<code>ONLY_DIAG = .true.</code>) ! ! @warning ! Issuing a non-FULL computation is indeed good in terms of ! <ul> !   <li>speed: much less computations required</li> !   <li>memory: also, much less memory allocated (no need to allocate the whole tensors, !       if only the diagonal elements are used)</li> ! </ul> ! On the other hand, non-FULL computations are <b>highly</b> discouraged ! in terms of results accuracy. ! </span> logical :: bool end function module subroutine bsa_setAnalysisType ( isuban ) !# <span style=\"white-space: pre-line\"> ! Sets analysis type. ! Valid options: ! <ol> !   <li>\\mathtt{Classic}</li> !   <li>\\mathtt{Mesher}</li> !   <li>\\mathtt{Both}</li> ! </ol> ! </span> integer ( bsa_int_t ), value :: isuban end subroutine module subroutine bsa_setClassicMode ( i_mode ) !# <span style=\"white-space: pre-line\"> ! Sets \\mathtt{Classic} computation mode. ! Valid options: ! <ol> !  <li> <code> BSA_CLASSIC_MODE_VECTOR </code> !     The internal <i>vectorised</i> implementation is used (DEFAULT). !     This is indeed the preferred option in terms of speed. !     There is however a limitation of this approach: !     since it requires a considerable amount of alocated memory, !     and considered the limit of memory that is requirable to the runtime !     (before going to unoptimised mechanisms, such swap partition) !     if a given limit (\\approx 8 Gb) is exceeded, the `BsaLib` runtime !     automatically switches to a <i>scalar</i> implementation. !   </li> !  <li> <code> BSA_CLASSIC_MODE_SCALAR </code> !     The internal <i>scalar</i> implementation is used. !     While this implementation is slower than its vectorised counterpart, !     it is certainly the one to be used to limit memory the footprint. !     Also, for very big cases, the `BsaLib` runtime might automatically switch !     to this implementation is too much memory allocation is required. !   </li> ! </ol> ! </span> integer ( bsa_int_t ), value :: i_mode end subroutine module subroutine bsa_setVersion ( ivers ) !! @warning !! Deprecated. integer ( bsa_int_t ), value :: ivers end subroutine module subroutine bsa_setScalingConv ( iconv ) !# <span style=\"white-space: pre-line\"> ! Set Power-Spectral-Density (PSD) integration convention. ! There are two fundamental integration conventions: ! <ol> !  <li> !    The <i>frequency</i> convention (<code>BSA_PSD_CONVENTION_FREQ</code>), !    where the integral of the PSD from 0 to +\\infty gives the variance !     m_2 = \\sigma&#94;2 = \\int_0&#94;{+\\infty} S(f) df.  !     </li> !  <li> !    The <i>pulsation</i> convention (<code>BSA_PSD_CONVENTION_PULS</code>), !    where the integral of the PSD from -\\infty to +\\infty gives the variance !     m_2 = \\sigma&#94;2 = \\int_{-\\infty}&#94;{+\\infty} S(\\omega) d\\omega.  !     </li> ! </ol> ! ! @note ! By DEFAULT, <code>BsaLib</code> uses the convention on <i>pulsations</i> (<code>BSA_PSD_CONVENTION_FREQ</code>). ! </span> integer ( bsa_int_t ), value :: iconv end subroutine module subroutine bsa_setSpectraComputation ( ipsd , ibisp ) !! Gives control on which kind of spectral features are computed. integer ( bsa_int_t ), value :: ipsd !! If 1, activates computation of Spectra (2&#94;{\\mathrm{nd}} order statisitcs) integer ( bsa_int_t ), value :: ibisp !! If 1, activates computation of Bispectra (3&#94;{\\mathrm{rd}} order statisitcs) end subroutine module subroutine bsa_setSpectraExtension ( ionlydiag ) !# <span style=\"white-space: pre-line\"> ! Sets extension of statistical information. ! There are two possible scenarios: ! <ul> !   <li><code>FULL</code> !     All elements of the 2D and 3D tensors of Spectra and Bispectra are computed. !     This is indeed the most accurate analysis. !      </li> !   <li><code>ONLY_DIAG</code> !     Only elements of the main diagonal are computed. !     While this approach is faster, and consumes much less memory, it is not !     recommended for results accuracy issues. !      </li> ! </ul> ! ! @note ! By DEFAULT, <code>BsaLib</code> performs a <code>FULL</code> analysis. ! </span> integer ( bsa_int_t ), value :: ionlydiag end subroutine module subroutine bsa_setTestMode ( itest ) !# <span style=\"white-space: pre-line\"> ! Enables testing mode. ! ! @warning ! If testing mode is enabled, some important features and checks are turned OFF. ! Use with care. ! <span> integer ( bsa_int_t ), value :: itest end subroutine module subroutine bsa_setupClassic ( nfreqs , df ) !# <span style=\"white-space: pre-line\"> ! Main setup data for the \\mathtt{Classic} approach. ! ! @warning ! If testing mode is OFF, these values might be internally modified in order to ! meet some minimum accuracy requirements. ! </span> integer ( bsa_int_t ), value :: nfreqs !# <span style=\"white-space: pre-line\"> !  number of discretisation points (i.e. n. of frequencies) ! ! @note ! Refers to the interval [0, f_{max}]. ! If the <i>pulsations</i> convention is used (<code>BSA_PSD_CONVENTION_PULS</code>), ! then this number will be automatically actualised to the interval [-f_{max},f_{max}]. ! <span> real ( bsa_real_t ), value :: df !# <span style=\"white-space: pre-line\"> ! Spacing between discretisation points (i.e. delta \\Delta f) ! </span> end subroutine module subroutine bsa_setupMesher ( isvd , bkgrfmt , bkgaext , genpaext , maxaext , ifcov , idumpmod ) !# <span style=\"white-space: pre-line\"> ! Main setup data for the \\mathtt{Mesher} approach. ! </span> integer ( bsa_int_t ), value :: isvd !! If `1`, enables use of POD techniques to decompose !! Cross-Spectral-Density-Matrices of base wind turbulence. integer ( bsa_int_t ), value :: bkgrfmt !! Defines the base n. of refinement points N_{bkg} used to mesh the !! background (quasi-static) zone, placed at the origin (0, 0). !! !! @note !! Several other zones' discretisation depend on this value. real ( bsa_real_t ), value :: bkgaext !! Defines the factor by which the background zone is extended. !! This is done to allow the user extending this zone, avoiding cutting !! the zone's extensions where gradients are still important. !! Acts as a safety factor. real ( bsa_real_t ), value :: genpaext !! Defines the factor by which the any peak zone is extended. !! Same reasons as for the background zone. real ( bsa_real_t ), value :: maxaext !! Defines the factor by which the total covered area f_{max} is extended. !! In this case, this is done to avoid loosing information coming from the !! secondary peaks, which are usually placed at extensions up to 2\\cdot f_i, !! where f_i is the i-th modal frequency. integer ( bsa_int_t ), value :: ifcov !! @warning !! Deprecated integer ( bsa_int_t ), value :: idumpmod !! If `1`, includes modal data in the `dumpfile`. !! !! @note !! While it is not optimal in terms of disk usage, !! it is certainly recommended in order to keep needed information all in one place. end subroutine ! ************************************** !    WIND ! ************************************** module subroutine bsa_setWindDirections ( dirs , ndirs ) integer ( bsa_int_t ), intent ( in ) :: dirs (:) integer ( bsa_int_t ), value , optional :: ndirs end subroutine module subroutine bsa_setWindTurbComps ( tc , ntc ) !# <span style=\"white-space: pre-line\"> ! Specifies which turbulent components, among \\{u, v, w\\}, should be considered ! in the definition of wind loads, and for which PSDs will be computed. ! </span> integer ( bsa_int_t ), intent ( in ) :: tc (:) !! Array of components. Each array element value should !! be equal to one of \\{1:u,\\ 2:v,\\ 3:w\\}. integer ( bsa_int_t ), value , optional :: ntc !! total n. of turbulent components to consider. end subroutine module subroutine bsa_setWindVertProf ( iwprof ) !# <span style=\"white-space: pre-line\"> ! Sets the wind vertical profile. ! Valid options: ! <ol> !   <li> <code>BSA_WIND_VERT_PROFILE_POWER</code>: uses a power law !          \\overline{U}(z) = \\left({\\frac{z}{z_{ref}}}\\right)&#94;{\\alpha}  !       </li> !   <li> <code>BSA_WIND_VERT_PROFILE_LOG</code>: uses a logarithmic law !          \\overline{U}(z) = {\\frac{1}{k}}\\sqrt{\\frac{\\tau_0}{\\rho}}\\ln{\\frac{z}{z_0}}  !       </li> ! </ol> ! </span> integer ( bsa_int_t ), value :: iwprof end subroutine module subroutine bsa_setPSDType ( ipsd ) !# <span style=\"white-space: pre-line\"> ! Sets base wind turbulence PSD (Power Spectral Density). ! Valid options: ! <ul> !   <li> <code>BSA_WIND_PSD_VONKARMAN</code>: VonKarman spectum: !       </li> !   <li> <code>BSA_WIND_PSD_KAIMAL</code>: Kaimal spectrum !       </li> !   <li> <code>BSA_WIND_PSD_DAVENPORT</code>: Davenport spectrum !       </li> ! </ul> ! </span> integer ( bsa_int_t ), value :: ipsd end subroutine module subroutine bsa_setWindAltDir ( ivert ) !# <span style=\"white-space: pre-line\"> ! Specifies which of the 3 Euclidean axes of the Wind Reference coordinate System ! is to be accounted as vertical axis. ! ! @note ! This is an important detail, which affect how altitudes and so wind speeds ! are determined. ! </span> integer ( bsa_int_t ), value :: ivert !! Axis index, with value among one of \\{1:x,2:y,3:z\\}. end subroutine module subroutine bsa_setWindZoneLimits ( lim , ilim ) !# <span style=\"white-space: pre-line\"> ! Sets limits defining wind zones. ! In real cases, if the structural system spans long distances horizontally (bridges), or vertically (skyscrapers), ! it might happen that the wind characteristics (wind speed, turbulence scales, etc.) change, so that ! applying a unique wind all along would be physically incorrect. ! To do so, more than one <q>wind zone</q> can be defined, to provide differentiation of wind characteristics along the structure. ! ! @warning ! Limits are usually considered to be defined along the X-axis of the ! Global Reference coordinate System (GRS), assuming horizontal structural ! systems, such as long-span bridges. ! In a later implementation, freedom to choose on which axis defining the wind ! zones MUST be given, for flexibility and correctness reasons. ! </span> #if  ((defined(__INTEL_COMPILER_BUILD_DATE)) && (__INTEL_COMPILER_BUILD_DATE >= 20221019)) real ( bsa_real_t ), intent ( in ) :: lim (..) integer ( bsa_int_t ), intent ( in ), optional :: ilim (..) #else real ( bsa_real_t ), intent ( in ), target :: lim (:) integer ( bsa_int_t ), intent ( in ), optional :: ilim (:) ! limits' index passed #endif end subroutine module subroutine bsa_setAirDensity ( aird ) !! Specifies a custom value for air density \\rho_{air}. !! Defaults to 1.225 \\ \\mathrm{kg/m&#94;3}. real ( bsa_real_t ), value :: aird end subroutine module subroutine bsa_setGlobalRotMatW2G ( rotW2G ) !# <span style=\"white-space: pre-line\"> ! Sets global rotation matrix from WRS to GRS. ! Different are the rotation matrices from the local WRS (local to a wind zone), and the GRS. ! For those, see <code>[[bsalib(module):bsa_setwzrotmatw2g(interface)]]</code>. ! </span> real ( bsa_real_t ), intent ( in ) :: rotW2G ( 3 , 3 ) end subroutine module subroutine bsa_setWZMeanWindVel ( mat ) !! Defines mean wind speeds \\overline{U}, for each wind zone. real ( bsa_real_t ), target , intent ( in ) :: mat (:) end subroutine module subroutine bsa_setWZRefAlt ( Zref ) !! Defines reference altitudes z_{ref}, for each wind zone. real ( bsa_real_t ), target , intent ( in ) :: Zref (:) end subroutine module subroutine bsa_setTurbWindScales ( L ) !# <span style=\"white-space: pre-line\"> ! Defines wind turbulence scales \\mathbf{L} !  \\begin{Bmatrix} !       L_{ux} && L_{vx} && L_{wx}\\\\L_{uy} && L_{vy} && L_{wy}\\\\L_{uz} && L_{vz} && L_{wz} !    \\end{Bmatrix}  ! for each wind zone. ! </span> real ( bsa_real_t ), target , intent ( in ) :: L ( 3 , 3 , * ) end subroutine module subroutine bsa_setTurbWindSDT ( sigma ) !# <span style=\"white-space: pre-line\"> ! Defines wind turbulence standard deviation \\boldsymbol{\\sigma}, for each wind zone. ! This is directly linked to the <i>turbulence intensity</i> I_{\\{u,v,w\\}}, defined as: !  I_{\\{u,v,w\\}} = \\frac{\\sigma_{\\{u,v,w\\}}}{\\overline{U}}  ! </span> real ( bsa_real_t ), target , intent ( in ) :: sigma ( 3 , * ) end subroutine module subroutine bsa_setWindCorrCoeffs ( ccoeffs ) !# <span style=\"white-space: pre-line\"> ! Defines the coefficients C_{\\mu\\xi} !  \\mathbf{C} = \\begin{Bmatrix} !       C_{ux} && C_{vx} && C_{wx}\\\\C_{uy} && C_{vy} && C_{wy}\\\\C_{uz} && C_{vz} && C_{wz} !    \\end{Bmatrix}  ! used in the decreasing-exponential formulation of wind spatial coherence. ! </span> real ( bsa_real_t ), target , intent ( in ) :: ccoeffs ( 3 , 3 , * ) end subroutine module subroutine bsa_setWindCorrExpnts ( cexpn ) !# <span style=\"white-space: pre-line\"> ! Defines the exponent coefficients p_{\\mu\\xi} !  \\mathbf{P} = \\begin{Bmatrix} !       p_{ux} && p_{vx} && p_{wx}\\\\p_{uy} && p_{vy} && p_{wy}\\\\p_{uz} && p_{vz} && p_{wz} !    \\end{Bmatrix}  ! used in the decreasing-exponential formulation of wind spatial coherence. ! </span> real ( bsa_real_t ), target , intent ( in ) :: cexpn ( 3 , 3 , * ) end subroutine module subroutine bsa_setIncidenceAngles ( incang ) !# <span style=\"white-space: pre-line\"> ! Defines wind mean incidence angle \\overline{i}, for each wind zone. ! </span> real ( bsa_real_t ), target , intent ( in ) :: incang (:) end subroutine module subroutine bsa_setWZRotMatW2G ( rotW2G_L ) !# <span style=\"white-space: pre-line\"> ! Defines the rotation matrix from the wind zone's local wind reference system (WRSl), to the global one (GRS). ! This to allow different principal wind flow directions for each wond zone. ! </span> real ( bsa_real_t ), target , intent ( in ) :: rotW2G_L ( 3 , 3 , * ) end subroutine module subroutine bsa_setNodalVel ( Unod ) !# <span style=\"white-space: pre-line\"> ! Provides mean wind speeds \\overline{U}_{i} at all structural nodes i. ! ! @note ! If this API call is made, then all the wind characteristics info (e.g. turbulence scales, turbulence intensities, etc.) ! are not needed, since they serve computing the final nodal wind speeds, which ! this API call provides already. ! @endnote ! ! @warning ! Currently, wind speeds at all <b>nodes</b> must be given, even if ! not all of them are actually under the wind lading action. ! Info on which nodes are effectively loaded is needed, so that internally, ! the distinction can be done. ! ! @warning ! <b>Will be deprecated</b> ! </span> real ( bsa_real_t ), target , intent ( in ) :: Unod (:) end subroutine module subroutine bsa_setNodalWindZones ( NodWZ ) !# <span style=\"white-space: pre-line\"> ! Provides info on each node's wind zone. That is, in which wind zone each node is located. ! ! @warning ! <b>Will be deprecated</b> ! </span> integer ( bsa_int_t ), target , intent ( in ) :: NodWZ (:) end subroutine module subroutine bsa_setNodalWindAltitudes ( WnodAlt ) !# <span style=\"white-space: pre-line\"> ! Sets altitude for each node. ! ! @warning ! In a later implementation, this should be internally deferred based on ! the selected vertical wind axis, and nodal coordinates. ! @endwarning ! ! @warning ! <b>Will be deprecated</b> ! </span> real ( bsa_real_t ), target , intent ( in ) :: WnodAlt (:) end subroutine module subroutine bsa_setSpatialNodalCorr ( nodCorr ) !! @warning !! <b>Will be deprecated</b> real ( bsa_real_t ), target , intent ( in ) :: nodCorr (:, :) end subroutine module subroutine bsa_setWindFCoeffs ( wfc ) !! @warning !! <b>Will be deprecated</b> real ( bsa_real_t ), target , intent ( in ) :: wfc (:, :, :) !! Dimensions should be [nlibs_l, ndegw+3, nnodes_l] end subroutine module subroutine bsa_setPhitimesC ( phiTc ) !! @warning !! <b>Will be deprecated</b> real ( bsa_real_t ), target , intent ( in ) :: phiTc (:, :, :) end subroutine ! ************************************** !    STRUCTURE ! ************************************** module subroutine bsa_setNodalCoords ( nn , coords ) !! Provides nodal spatial coordinates. integer ( bsa_int_t ), value :: nn !! total number of nodes. real ( bsa_real_t ), target , contiguous :: coords (:, :) !! Dimensions `[3, nn]`, where `3` refers to the 3 spatial !! directions \\{x,y,z\\}. end subroutine module subroutine bsa_setTotalNumOfDOFs ( ndofs ) !# <span style=\"white-space: pre-line\"> ! Provides the total number of structural degrees-of-freedom \\mathtt{NDOFs}. !  \\mathtt{NDOFs} = \\mathtt{NN} \\cdot \\mathtt{NNDOFs}  ! where \\mathtt{NN} is the total number of structural nodes, ! \\mathtt{NNDOFs} the number of degrees-of-freedom per node. ! </span> integer ( bsa_int_t ), value :: ndofs end subroutine module subroutine bsa_setNumOfNodalDOFs ( nndofs ) !# <span style=\"white-space: pre-line\"> ! Sets number of total degrees-of-freedom per node \\mathtt{NNDOFs}. ! </span> integer ( bsa_int_t ), value :: nndofs end subroutine module subroutine bsa_setTotalNOfNodes ( nn ) !# <span style=\"white-space: pre-line\"> ! Sets number of total structural nodes \\mathtt{NN}. ! </span> integer ( bsa_int_t ), value :: nn end subroutine module subroutine bsa_setLoadedNodalDOFs ( libs_l , nlibs_l ) !# <span style=\"white-space: pre-line\"> ! Sets number of nodal DOFs effectively loaded \\mathtt{NNDOFsL}, ! where the ending \\mathtt{L} signifies <q>loaded</q>. ! ! @note ! This API call is optional. If not called, `BsaLib` automatically sets the number of ! loaded nodal DOFs to the maximum, \\mathtt{NNDOFs} (see <code>[[bsalib(module):bsa_setnumofnodaldofs(interface)]]</code>). ! </span> integer ( bsa_int_t ), intent ( in ), target , allocatable :: libs_l (:) !! Array of loaded nodal DOFs. !! @note !! Each array element value must be included in the range !! \\{[1, \\mathtt{NNDOFs}]\\}, where \\mathtt{NNDOFs} is the total !! n. of nodal degrees-of-freedom (see <code>[[bsalib(module):bsa_setnumofnodaldofs(interface)]]</code>). integer ( bsa_int_t ), value , optional :: nlibs_l !! N. of passed loaded nodal DOFs. end subroutine module subroutine bsa_setLoadedNodes ( nodes_l , nn_l ) !# <span style=\"white-space: pre-line\"> ! Sets number of structural nodes effectively loaded \\mathtt{NNL}, ! where the ending \\mathtt{L} signifies <q>loaded</q>. ! ! @note ! This API call is optional. If not called, `BsaLib` automatically sets the number of ! loaded nodes to match all nodes, \\mathtt{NN} (see <code>[[bsalib(module):bsa_settotalnofnodes(interface)]]</code>). ! </span> integer ( bsa_int_t ), intent ( in ), target , allocatable :: nodes_l (:) integer ( bsa_int_t ), value , optional :: nn_l end subroutine module subroutine bsa_setModalInfo ( ndofs , nm , Phi , natf ) !# <span style=\"white-space: pre-line\"> ! Provides info about structural modal vibrations. ! Namely, the structural modal matrix \\boldsymbol{\\Phi} (eigenmatrix) <code>Phi</code> and the relative natural frequencies \\mathbf{f} (eigenvalues) <code>natf</code>. ! ! @note ! As a layer of internal verification and correctness checks, this API call forces to specify ! dimensions of the modal matrix (in order). ! Usually, they are the total number of structural degrees-of-freedom (see ! <code>[[bsalib(module):bsa_settotalnumofdofs(interface)]]</code>) ! and the number of vibration modes. ! If for any reason, a value mismatch is caught, <code>BsaLib</code> wil throw an internal error. ! </span> integer ( bsa_int_t ), value :: ndofs , nm real ( bsa_real_t ), intent ( in ), target :: Phi ( ndofs , nm ), natf ( nm ) end subroutine module subroutine bsa_setKeptModalShapes ( modes ) !# <span style=\"white-space: pre-line\"> ! This API call allows to specify a list of vibration modes to be actually accounted for in the computation. ! It might be tought to directly ask the user to provide <b>only</b> the modes to be used, ! when using the <code>[[bsalib(module):bsa_setmodalinfo(interface)]]</code> API call. ! However, this might limit API flexibility, so that the user is given the chance to ! give a list of indexes, and restrict the computation to those indexes only, ! without requiring to bother to much on how the modal vibration information is given. ! </span> integer ( bsa_int_t ), intent ( in ) :: modes (:) end subroutine module subroutine bsa_setModalMatrices ( nm , Mgen , Kgen , Cgen ) !# <span style=\"white-space: pre-line\"> ! Provides structural modal matrices of mass, stiffness and damping, respectively. ! ! @note ! At the current stage, <code>BsaLib</code> depends on some basic functionalities of ! common Finite-Element (FE) software, such as determining the modal matrix of a structure. ! This choice has been made in order not to bind <code>BsaLib</code> to any specific ! implementation, and let the final user the choice of the method used to determine these matrices. ! @endnote ! ! @warning ! As per the current implementation, only symmetric modal mass and stiffness matrices are ! considered, meaning that in fact, the modal matrix \\boldsymbol{\\Phi} given in ! <code>[[bsalib(module):bsa_setmodalinfo(interface)]]</code> is obtained by solving the ! following Eigenvalue problem: !  \\mathbf{K}\\boldsymbol{\\Phi} = \\mathbf{M}\\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}  ! where \\mathbf{K} and \\mathbf{M} are the structural stiffness and mass matrices, ! \\boldsymbol{\\Lambda} a diagonal matrix containing the coefficients of the characteristic ! polynomial equation. ! In such cases, the resulting modal mass and stiffness matrices !  \\mathbf{K}&#94;\\star = \\boldsymbol{\\Phi}&#94;T\\mathbf{K}\\boldsymbol{\\Phi}; \\quad \\quad !    \\mathbf{M}&#94;\\star = \\boldsymbol{\\Phi}&#94;T\\mathbf{M}\\boldsymbol{\\Phi}  ! will be diagonalised by \\boldsymbol{\\Phi}. ! Therefore, only the diagonal elements are required by <code>BsaLib</code>. ! </span> integer ( bsa_int_t ), value :: nm !! n. of vibration modes !! @note Should match with the one given in <code>[[bsalib(module):bsa_setmodalinfo(interface)]]</code>. real ( bsa_real_t ), intent ( in ), target , dimension ( nm ) :: Mgen , Kgen !! real ( bsa_real_t ), intent ( in ), target :: Cgen ( nm , nm ) end subroutine module subroutine bsa_setTotDamping ( xsi ) !# <span style=\"white-space: pre-line\"> ! Provides modal damping ratios \\xi_i \\ \\ \\forall i=1,\\dots,\\mathtt{NM}. ! ! @note ! This should include any possible source of damping, from structural damping ! to aerodynamic damping in case of wind loading, etc. ! </span> real ( bsa_real_t ), target , intent ( in ) :: xsi (:) end subroutine pure module function bsa_getUsedModeShapes () result ( modes ) !# <span style=\"white-space: pre-line\"> ! Returns a copy of the array of effectively used vibration modes. ! </span> ! This is directly linked to <code>[[bsalib(module):bsa_dovalidatemodaldata(interface)]]</code>, ! or <code>[[bsalib(module):bsa_setkeptmodalshapes(interface)]]</code> (even though this last ! API call contains the same info, provided by the user). integer ( bsa_int_t ), allocatable :: modes (:) end function ! ************************************** !    COMPUTE ! ************************************** module subroutine bsa_computeBRdecomp ( m2mf , bkg , res ) !# Returns the Background-Resonant decomposition, given the second order statistical moments ! \\mathbf{m}_2 of the modal loads. ! ! @note ! This is an API call to be used in a post-processing phase. real ( bsa_real_t ), intent ( in ) :: m2mf (:) real ( bsa_real_t ), allocatable , intent ( out ) :: bkg (:), res (:) end subroutine module subroutine bsa_computePeakFactors (& m2 , m2o2 , obs_time , peak_g , sk , peak_ng_pos , peak_ng_neg ) !# Computes Gaussian and Non-Gaussian Peak factors. ! Formulations are taken from CITE!. ! ! @note ! This is an API call to be used in a post-processing phase. real ( bsa_real_t ), intent ( in ) :: m2 (:) real ( bsa_real_t ), intent ( in ) :: m2o2 (:) real ( bsa_real_t ), intent ( in ) :: obs_time real ( bsa_real_t ), allocatable , intent ( inout ) :: peak_g (:) real ( bsa_real_t ), allocatable , intent ( in ) :: sk (:) real ( bsa_real_t ), allocatable , intent ( inout ) :: peak_ng_pos (:) real ( bsa_real_t ), allocatable , intent ( inout ), optional :: peak_ng_neg (:) end subroutine ! ************************************** !    I/O  -  EXPORTING ! ************************************** module subroutine bsa_setOutputDirectory ( dirname ) !! Sets output directory. character ( len =* ), intent ( in ) :: dirname end subroutine module subroutine bsa_setOutFileName ( fname ) !! @warning Deprecated. character ( len =* ), intent ( in ) :: fname end subroutine module subroutine bsa_setOutUnit ( iunit ) !! Sets unit to be used for the output file. !! Useful if needed to use an already opened unit from hosting program unit. integer ( bsa_int_t ), value :: iunit end subroutine module subroutine bsa_closeUnitsAtEnd () !! If called, tells `BsaLib` to close internal unit handles at exit. !! This is not a wanted behaviour if, for example, output unit is taken from !! hosting program unit (see <code>[[bsalib(module):bsa_setoutunit(interface)]]</code>), !! and might be used even after `BsaLib` returns from main (<code>[[bsalib(module):bsa_run(interface)]]</code>). end subroutine module subroutine bsa_setExportFileFormat ( iform ) !! Defines the desired format (e.g. `FORMATTED/UNFORMATTED`) to be used when exporting !! statistical moments to files. integer ( bsa_int_t ), value :: iform !! Format flag, see `BSA_EXPORT_FORMAT_*`. end subroutine module subroutine bsa_setExportAppendMode ( imode ) !! @warning Deprecated. integer ( bsa_int_t ), value :: imode end subroutine module subroutine bsa_setExportDirectory ( dirname ) !! Defines a directory to place all the exporting of computed statistical moments, !! when invoking any of the related API calls !! (see for instance <code>[[bsalib(module):bsa_exportmomenttofile(interface)]]</code>). character ( len = * ), intent ( in ) :: dirname end subroutine module subroutine bsa_setExportInCurrDir () !! Differently from <code>[[bsalib(module):bsa_setexportdirectory(interface)]]</code>, !! this API call telss `BsaLib` to place all exports in the current working directory. end subroutine module subroutine bsa_exportBR_nocompute_ ( fname , bkg , res , xsi ) !! Exports the Background-Resonant decomposition, computing it internally !! (see <code>[[bsalib(module):bsa_computebrdecomp(interface)]]</code>). character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ) :: bkg (:), res (:), xsi (:) end subroutine module subroutine bsa_exportMomentToFile ( fname , vec ) !! Exports given statistical moments to file. `fname` is the file name. !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ) :: vec (:) end subroutine module subroutine bsa_exportSkewness_nocompute_ ( fname , sk ) !! Exports skewness to file, no internal computation. !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ) :: sk (:) end subroutine module subroutine bsa_exportSkewness_compute_ ( fname , dim , m2 , m3 ) !! Exports skewness to file, with internal computation prior to write. !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname integer ( bsa_int_t ), value :: dim !# @note `dim` represents the principal dimension of the square tensors of ! 2nd and 3rd statistical moments. ! So that: ! <ul> !   <li>if a non-FULL computation (see <code>[[bsalib(module):bsa_isfullcomp(interface)]]</code>) !         is issued, then `dim` is equal to the array extensions. </li> !   <li> otherwise, `dim` refers to the characteristic square tensors dimension !         (i.e. as if they were computed in a non-FULL case). !         Then, the correct indexes are computed internally. </li> ! </ul> real ( bsa_real_t ), intent ( in ) :: m2 (:) real ( bsa_real_t ), intent ( in ) :: m3 (:) end subroutine module subroutine bsa_exportPSDToFile ( fname , psd , f ) !! Exports series of PSDs (defined at frequencies `f`) to file. !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ) :: psd (:, :) real ( bsa_real_t ), intent ( in ), optional :: f (:) end subroutine module subroutine bsa_exportBispToFile ( fname , bisp ) !! Exports series of Bispectra to file. !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ) :: bisp (:, :, :) end subroutine module subroutine bsa_saveCoordinatesToFile ( fname , coords ) !! Exports nodal coordinates to file !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ), target , optional :: coords (:, :) end subroutine module subroutine bsa_exportModalData () !! Exports modal data to file names `modal.txt`. !! !! @note !! Uses a `FORMATTED` output. !! !! @warning Will be deprecated. end subroutine module subroutine bsa_exportExtremeValuesToFile ( fname , rvar ) !! Exports extreme (or peak) values to file. !! !! @note !! Uses a `FORMATTED` output. character ( len = * ), intent ( in ) :: fname real ( bsa_real_t ), intent ( in ) :: rvar (:) end subroutine module subroutine bsa_setBRMExportDefaultMode ( imode ) !! Specifies the desired mode of exporting Bispectra (assumes bispectra computation is turned ON). !! !! @note !! Real data is exported as `real(real32)` from the `iso_fortran_env` intrinsic module. !! !! @warning !! Contrary to the <q>visual mode</q> (see <code>[[bsalib(module):bsa_enablevisualmode(interface)]]</code>), !! this API call enables exporting when actually doing the real computation. !! That is, in the case of the \\mathtt{Mesher} approach, the Pre-mesh phase is not skipped. !! <b>All</b> bispectra are exported, so expect to have big files generated. !! @endwarning integer ( bsa_int_t ), value :: imode end subroutine module subroutine bsa_setBispExportCallback ( fptr ) !! Allows to specify a custom function callback for exporting bispectra. !! Applies to both cases of !! <code>[[bsalib(module):bsa_enablevisualmode(interface)]]</code> and !! <code>[[bsalib(module):bsa_setbrmexportdefaultmode(interface)]]</code> procedure ( exportInterf_vect_ ), pointer , intent ( in ) :: fptr !! Function callback. end subroutine end interface ! ************************************************************************************** !    INTERFACE FOR PRIVATE PROCEDURES ! ************************************************************************************** interface module subroutine mainClassic_ ( m2mf_cls , m2mr_cls , m2o2mr_cls , m3mf_cls , m3mr_cls ) real ( bsa_real_t ), allocatable , intent ( inout ), target :: & m2mf_cls (:), m2mr_cls (:), m2o2mr_cls (:), m3mf_cls (:), m3mr_cls (:) end subroutine module subroutine mainMesher_ ( m3mf_msh , m3mr_msh ) real ( bsa_real_t ), target , allocatable :: m3mf_msh (:), m3mr_msh (:) end subroutine end interface private :: mainClassic_ , mainMesher_ ! BUG: these might be moved, and called via an internal function pointer. private :: bsa_exportSkewness_compute_ , bsa_exportSkewness_nocompute_ private :: bsa_exportBR_nocompute_ end module BsaLib","tags":"","loc":"sourcefile\\bsalib.f90.html"}]}